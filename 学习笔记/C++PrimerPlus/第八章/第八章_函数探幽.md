# 第八章_函数探幽

## 内联函数

当我们使用函数，会使得函数从当前位置跳跃到另一个位置开始执行，还需要记住当前位置以便返回，然后来回跳跃和记忆是需要时间的，所以C++提供了另外一种方式也就是**内联函数**,内联函数的编译代码与其他的程序代码“内联”起来了，也就是说编译器将会使用相应的内联函数的代码替换函数调用，对于内联函数程序无需跳转到另一个位置。所以内联函数运行速度比常规函数稍快，但代价是占用更多内存，如果一个程序在不同的10处内联函数调用，那么这个程序将包含这段代码的十个副本。

如果执行函数代码比处理函数调用机制的时间长，则不需要内联函数，省去的时间有限。若果执行函数代码时间远小于处理函数调用机制时间，则可以考虑使用内联函数。

内联函数适用于 函数调用机制所占用的时间占据总时间相当比例，且函数调用频繁，且调用口不多的函数类型。

（有些时候特定的表达式可以用内联函数表示，清晰清楚，且省去了函数调用机制的消耗的时间）

### 内联函数的实现

要使用内联函数必须要在声明和定义的前面加上关键字 inline，通常的做法是省去原型从而直接实现。（内联本身较短）

```c++
inline double square(int x){
    return x * x;
}
```

但是并不是所有的内联函数请求都会被满足，编译器可能认为该函数过大，或者函数存在递归的美好

### 内联函数与宏函数

我们注意到我们有时候也使用宏函数来处理以上提到的函数调用机制占用时间过大的问题，在解决这个问题的情况下，宏函数似乎比内联函数更加彻底，基于文本替换的宏定义，完全省去了函数调用机制，似乎远胜于内联函数？其实不然正应为基于文本替换导致了许多很隐蔽的问题，看如下宏函数

```cpp
#define SQUARE(x) x*x
```

来看一组调用

```c++
SQUARE(1) //-> 1*1 = 1 -> 正确
SQUARE(1+1) //-> 1 + 1 * 1 + 1 = 3 ->错误
// 假设 a=1
SQUARE(a++) //-> a++ * a++ -> 错误 在同一条语句多次对同一个变量进行自增自减会出现未定义的结果 
```

我们发现宏函数在处理很多问题的时候出现很多的问题，所以在C++开发中我们更加推荐使用内联函数替代宏函数

## 引用变量

### 引用变量的实现

在C++中允许使用 & 符号来声明引用

```cpp
int a = 1;
int & b = a; // b 是 a 的别名且 &b == &a
```

**引用在声明的时候必须初始化，而指针可以先声明再赋值**

且引用不许更改引用对象

```cpp
int a = 1;
int & b = a;
int c = 2;
b = c // ? &b == &c NO! ,&b == &a a == b == c
```

看似更改了b的引用位置其实不然,只是将 c 的值赋给了 b，而b 是 a的别名，所以 b == c == a

### 引用函数作为函数参数

按引用传递能够允许被调用的函数能够访问调用函数的变量。C++这个特性是C语言所不存在的，C语言只允许按值传递，即使是可以突破的指针也是按值传递

```cpp
// 函数实现
void swap_Cstyle(int * a,int * b){
    int t = *a;
    *a = *b;
    *b = t;
}
void swap_Cppstyle(int & a,int & b){
    int t = a;
    a = b;
    b = t;
}

// 调用方式
int a = 1,b = 2;
swap_Cstyle( &a, &b); // C交换函数调用
swap_Cppsttle( a, b); // Cpp交换函数调用
```

使用基本数据类型时应该(推荐)使用按值传递，而不要使用按引用传递，当数据（类或者是结构）比较大的时候，引用参数将会很有用.

同时传递引用的会更加严格，实参应该是变量,而不是表达式。

当**参数为const**,如果实参与引用参数不匹配，C++生成临时变量。有以下两种情况

1. 实参类型正确，但不是左值（可以被取地址的值)

> 左值：可以被引用的数据对象，非左值包括字面常量（用引号扩起来的字符串除外，他们由地址表示）和包括多项式表达式
>
> 在C语言中左值最初是指可以出现在赋值语句左边的实体，，但是这是在引入const关键字之前的情况，现在const变量和常规变量都可以是为左值，但是常规变量属于可变左值，const变量属于不可变左值	

1. 实参类型错误，但是可以转换为正确的类型

来看以下例子

```cpp
#include <iostream>
void printa_nonconst(int & a){
	std::cout << a << std::endl;
}
void printa_const(const int & a){
	std::cout << a << std::endl;
}

int main(){
	int a = 1;
	printa_nonconst(a); // 允许
	printa_const(a); // 允许
    
    // printa_nonconst(1); 实参数不是变量 编译失败
	printa_const(1); // 参数为const引用，实参为类型正确，但不是左值，C++将创建临时变量
    
    int b = 2;
	printa_nonconst(b + 2); // 实参不是左值
	printa_const(b + 2); // 参数为const引用，实参为类型正确，但不是左值，C++将创建临时变量
    
    const int c = 1;
	//printa_nonconst(c);  // 不被允许，在被调用函数a是可改变的，但是实际上a是const，会导致const很荒诞。
}
```

### 应尽可能的使用 const 引用

1. 使用const引用可以避免无意中修改数据的编程错误
2. 使用const引用可以使得函数可以处理const和非const实参数，否则只能只能接受非const 实参。
3. 使用const引用可以使得函数正确生成和使用临时变量

### 将引用用于接受



