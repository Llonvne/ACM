# 第八章_函数探幽

## 内联函数

当我们使用函数，会使得函数从当前位置跳跃到另一个位置开始执行，还需要记住当前位置以便返回，然后来回跳跃和记忆是需要时间的，所以C++提供了另外一种方式也就是**内联函数**,内联函数的编译代码与其他的程序代码“内联”起来了，也就是说编译器将会使用相应的内联函数的代码替换函数调用，对于内联函数程序无需跳转到另一个位置。所以内联函数运行速度比常规函数稍快，但代价是占用更多内存，如果一个程序在不同的10处内联函数调用，那么这个程序将包含这段代码的十个副本。

如果执行函数代码比处理函数调用机制的时间长，则不需要内联函数，省去的时间有限。若果执行函数代码时间远小于处理函数调用机制时间，则可以考虑使用内联函数。

内联函数适用于 函数调用机制所占用的时间占据总时间相当比例，且函数调用频繁，且调用口不多的函数类型。

（有些时候特定的表达式可以用内联函数表示，清晰清楚，且省去了函数调用机制的消耗的时间）

### 内联函数的实现

要使用内联函数必须要在声明和定义的前面加上关键字 inline，通常的做法是省去原型从而直接实现。（内联本身较短）

```c++
inline double square(int x){
    return x * x;
}
```

但是并不是所有的内联函数请求都会被满足，编译器可能认为该函数过大，或者函数存在递归的美好

### 内联函数与宏函数

我们注意到我们有时候也使用宏函数来处理以上提到的函数调用机制占用时间过大的问题，在解决这个问题的情况下，宏函数似乎比内联函数更加彻底，基于文本替换的宏定义，完全省去了函数调用机制，似乎远胜于内联函数？其实不然正应为基于文本替换导致了许多很隐蔽的问题，看如下宏函数

```cpp
#define SQUARE(x) x*x
```

来看一组调用

```c++
SQUARE(1) //-> 1*1 = 1 -> 正确
SQUARE(1+1) //-> 1 + 1 * 1 + 1 = 3 ->错误
// 假设 a=1
SQUARE(a++) //-> a++ * a++ -> 错误 在同一条语句多次对同一个变量进行自增自减会出现未定义的结果 
```

我们发现宏函数在处理很多问题的时候出现很多的问题，所以在C++开发中我们更加推荐使用内联函数替代宏函数

## 引用变量

### 引用变量的实现

在C++中允许使用 & 符号来声明引用

```cpp
int a = 1;
int & b = a; // b 是 a 的别名且 &b == &a
```

**引用在声明的时候必须初始化，而指针可以先声明再赋值**

且引用不许更改引用对象

```cpp
int a = 1;
int & b = a;
int c = 2;
b = c // ? &b == &c NO! ,&b == &a a == b == c
```

看似更改了b的引用位置其实不然,只是将 c 的值赋给了 b，而b 是 a的别名，所以 b == c == a

### 引用函数作为函数参数

按引用传递能够允许被调用的函数能够访问调用函数的变量。C++这个特性是C语言所不存在的，C语言只允许按值传递，即使是可以突破的指针也是按值传递

```cpp
// 函数实现
void swap_Cstyle(int * a,int * b){
    int t = *a;
    *a = *b;
    *b = t;
}
void swap_Cppstyle(int & a,int & b){
    int t = a;
    a = b;
    b = t;
}

// 调用方式
int a = 1,b = 2;
swap_Cstyle( &a, &b); // C交换函数调用
swap_Cppsttle( a, b); // Cpp交换函数调用
```

使用基本数据类型时应该(推荐)使用按值传递，而不要使用按引用传递，当数据（类或者是结构）比较大的时候，引用参数将会很有用.

同时传递引用的会更加严格，实参应该是变量,而不是表达式。

当**参数为const**,如果实参与引用参数不匹配，C++生成临时变量。有以下两种情况

1. 实参类型正确，但不是左值（可以被取地址的值)

> 左值：可以被引用的数据对象，非左值包括字面常量（用引号扩起来的字符串除外，他们由地址表示）和包括多项式表达式
>
> 在C语言中左值最初是指可以出现在赋值语句左边的实体，，但是这是在引入const关键字之前的情况，现在const变量和常规变量都可以是为左值，但是常规变量属于可变左值，const变量属于不可变左值	

1. 实参类型错误，但是可以转换为正确的类型

来看以下例子

```cpp
#include <iostream>
void printa_nonconst(int & a){
	std::cout << a << std::endl;
}
void printa_const(const int & a){
	std::cout << a << std::endl;
}

int main(){
	int a = 1;
	printa_nonconst(a); // 允许
	printa_const(a); // 允许
    
    // printa_nonconst(1); 实参数不是变量 编译失败
	printa_const(1); // 参数为const引用，实参为类型正确，但不是左值，C++将创建临时变量
    
    int b = 2;
	printa_nonconst(b + 2); // 实参不是左值
	printa_const(b + 2); // 参数为const引用，实参为类型正确，但不是左值，C++将创建临时变量
    
    const int c = 1;
	//printa_nonconst(c);  // 不被允许，在被调用函数a是可改变的，但是实际上a是const，会导致const很荒诞。
}
```

### 应尽可能的使用 const 引用

1. 使用const引用可以避免无意中修改数据的编程错误
2. 使用const引用可以使得函数可以处理const和非const实参数，否则只能只能接受非const 实参。
3. 使用const引用可以使得函数正确生成和使用临时变量

### 将引用用于结构

引用非常适合用于结构和类(C++的用户自定义类型)，引入引用正是为了这种类型，而不是基本的内置类型

假设有以下结构

```cpp
typedef enum {MALE,FEMAIL,OTHER} Sex;
struct Person {
	std::string name;
	int age;
	Sex sex;
};
```

**常量引用**作为参数

```cpp
void display(const Person & person){
	const char charsOfSex[][7] = {"Male","Female"};
	const char formatOfName[] = "Name: %s\n";
	const char formatOfAge[] = "Age: %d\n";
	const char formatOfSex[] = "Sex: %s";
	
	printf(formatOfName,person.name.c_str());
	printf(formatOfAge,person.age);
	printf(formatOfSex,charsOfSex[person.sex]);
}
```

**非常量引用作为参数**，返回引用

```cpp
Person & initPerson(Person & person,std::string name,int age,Sex sex){
	person.name = name;
	person.age = age;
	person.sex = sex;
	return person;
}
```

**将返回的非常量引用引用作为常量引用的实参**

```cpp
display(initPerson(lcosvle,"lcosvle",20,MALE));
/* 运行结果
Name: lcosvle
Age: 20
Sex: Male
*/
```

**将非常量引用作为返回值**并赋值

```cpp
// 函数实现
std::string & setName(Person & person){
	return person.name;
}
// 执行代码
setName(lcosvle) = "lcosvle2";
display(lcosvle);
/* 结果
Name: lcosvle2
Age: 20
Sex: Male
*/
```

在理解非常量引用返回值的时候，可以将左边的函数体视作其返回的引用值，就是在给引用赋值，与函数实际无关.简单来说返回引用的函数实际上是引用的变量的别名。

**不应该返回函数终止时不再存在的内存单元的引用**如下

```cpp
Person & newPerson(std::string name,int age,Sex sex){
	Person newPerson{name,age,sex};
	return newPerson; // newPerson 变量将被释放，返回将会出错
}
```

如果不是返回引用则没有关系，或者返回传入的参数或者使用new来开辟内存

```cpp
Person newPerson(std::string name,int age,Sex sex){
	Person newPerson{name,age,sex};
	return newPerson; // newPerson将会被复制一份，没有问题
}
```

**为什么要将const用于引用返回类型**

假如你既需要返回引用值又需要不允许修改，则要使用const引用，如果将initPerson改用const引用返回

```cpp
const Person & initPerson(Person & person,std::string name,int age,Sex sex){
	person.name = name;
	person.age = age;
	person.sex = sex;
	return person;
}
```

则可以避免如下荒诞的错误

```cpp
initPerson(llonvne, "lonvne", 19, MALE) = lcosvle; // 将执行完函数的llonvne用lcosvle赋值
```

### 将引用用于类结构

将类对象传递给函数的时候，C++常用的方法是引用，例如可以通过引用让string,ostream类的对象等作为函数的参数。

```cpp
string insertAtBothStartAndEnd1(const string & a, const string & b)
{
    return b + a + b;
}
// 正确
const string & insertAtBothStartAndEnd2(string & a, const string & b)
{
    a = a + b + a;
    return a;
}
// 返回了正确的结果，但是导致了a被更改
const string & insertAtBothStartAndEnd3(const string & a, const string & b)
{
    string temp = b + a + b;
    return temp;
}
// 错误！ 返回了局部变量的引用
```

**使用C风格的字符串作为string对象的参数**

string类的对象可以接受一个C风格字符串有个条件

就是必须要将参数声明为 const 引用参数，才能调用string内置的转换 char * -> string 的转换功能

将原来的C风格字符串转换为一个临时变量（**必须要声明为常量引用,才能转换否则就会失败**）。

```cpp
cout << insertAtBothStartAndEnd1("123",a);
```

如下函数就不可以接受C风格字符串

```cpp
// 函数实现
string insertAtBothStartAndEnd1_nonconst(string & a, string & b)
{
    return b + a + b;
}
// 调用
// insertAtBothStartAndEnd1_nonconst("123", "###") 失败！非const引用只能接受左值
```

### 对象，继承和引用

**继承**：使得一个特性从一个类传递到另一个类的语言特性叫做继承

> 例如 ostream 作为基类(因为ofstream建立于它之上)，ofstream作为派生类(因为它是从ostream派生出来)。派生类继承了基类的方法，

继承的另一个特征是基类引用可以指向派生类对象，而无需进行强制转换。

> 例如参数类型为 ostream & 的对象可以接受ostream对象或者你声明的ofstream对象

### 何时使用引用参数

使用原因如下

1. 程序员能够修改调用函数的数据对象
2. 通过传递引用而不是整个数据对象，可以提高程序运行速度

当数据对象较大时，第二个原因最重要。

还有其他原则

对于**使用传递的值而不做修改的函数**

1. 如果数据对象很小，如内置数据类型或者小型结构，则按值传递
2. 如果数据对象时数组，使用指针，这是唯一的选择，且将指针声明const
3. 如果数据对象是较大的结构，使用const指针或者const引用，提高程序效率，节省复制结构所需要的时间和空间。
4. 如果数据对象是类对象，则使用const引用，类设计的语意常常要求使用引用。这是C++增加引用的主要原因，传递类对象的标准方式是引用传递。

对于**修改调用函数中数据的函数**

1. 如果数据对象是内置数据类型，则使用指针。
2. 如果是数组则使用指针
3. 如果是结构，使用指针或者结构
4. 如果是类对象，使用引用

以上只是指导原则，在特定条件下需要具体考虑，例如 cin >> n 使用引用而不是指针

## 默认参数

默认参数是指当函数调用的时候省略了实参自动使用的一个值.

```cpp
// 函数原型
void wow(int n = 1);
// 如果这样调用函数等价于 wow(1)
wow() // == wow(1)
```

对于带有参数列表的函数，必须从**右向左添加默认值**，也就是说，要为某个参数设置默认值，则必须为他右边的所有参数提供默认值。

实参按**从左往右的顺序依次被赋给相应的形参**，不能跳过任何参数，也就是说如果要使用某项参数的默认值，则所有在其右边的参数都必须为默认值.

以下的原型和调用都是非法的

```cpp
// 函数原型
int wow(int a,int b = 0,int c); // 提供默认参数的形式参数右边都必须提供默认参数

// 函数调用
int owo(int a,int b = 0,int c = 0); // 这个是合法的函数原型
owo(1); // 合法 等价于 owo(1,0,0);
owo(1,,1); // 非法，如果要使用某项形式参数的默认值则在其右边的参数也必须是默认值，该调用可以改写如下
owo(1,0,1); // 该调用是上述的合法形式
```

## 函数重载

函数多态是C++在C语言的基础上新增的功能，默认参数能让您能够使用不同数目的参数调用一个函数。而函数多态（函数重载）允许您创建多个同名函数。术语多态是指有多种形式，因此术语函数多态允许函数可以有多种形式，类似的术语**函数重载允许有多个同名函数**，对其名称进行了重载。这两个术语指的同一件事。但我们通常使用函数重载，可以通过函数重载来设计一系列函数，他们完成相同的功能，但使用**不同的参数列表**

>函数多态和函数重载的区别关键点：
>
>函数重载是静态绑定，编译阶段实现
>
>函数多态是动态绑定，运行阶段实现
>
>https://www.cnblogs.com/devilmaycry812839668/p/6362082.html

函数重载的关键是**参数列表**,也称为函数特征标（function signature 似乎函数签名会更好听？）,如果两个函数参数数目和类型相同且排列顺序也相同，则他们的特征标（签名）相同，变量名是无关紧要的。C++允许定义相同名称的函数但条件是特征标不同。

**注意**：如果函数名不同则两个函数一定不会相同，在函数名相同的情况则特征标一定要有区别，注意**返回值不足以区分函数**。

看一下的函数重载实例

```cpp
// 函数原型
void print(const char * str, int width);
void print(double d, int width);
void print(long l,int width);
void print(int i, int width);
void print(const char * str);

// 函数调用
print("Llonvne", 5); // #1
print(123.12,3); // #2
print(1234L,4); // #3
print(1234,4); // #4
print("Lcosvle"); //#5
```

在函数重载的时候，需要在**调用函数的时候提供正确的参数类型**，对于以下语句不会通过编译

```cpp
unsigned int year = 3210;
print(year, 4); // ambiguous call 模凌两可的函数调用
```

但是如果省去函数原型#2,#3反而能够通过编译，为什么呢，因为如果删去2，3就只剩下一个原型将数字视为第一个参数，C++会尝试将其转换为int型进行调用，但是**现在存在三个原型将数字视为第一个参数**，C++编译器该转换哪个去调用呢？编译器并不知道，C++将拒绝这种函数调用，将其视为一种错误！（三个和尚没水喝？)

**一些看起来彼此不同的特征标是无法共存的**，请看如下两个原型

```cpp
double cube(double x);
double cube(double & x);
```

对于这种请注意C++编译器在编译调用函数的时候，只会查看函数原型，而不去查看函数具体实现，类似于上述两种函数C++编译器根本无法在编译的时候确定该调用哪个函数。

**const变量与非const变量**

```cpp
// 函数原型
void dribble(char * bits); //overload;
void dribble(const char * cbits); //overload;
void dabble(char * bits); // not overloaded
void drivel(const char * bits); // not overloaded
// 函数调用
const char p1[20] = "How's the weather?";
char p2[20] = "How's the business?";
dribble(p1); // p1 is const char * -> void dribble(const char * cbits);
dribble(p2); // p2 is char * -> void dribble(char * bits);
dabble(p1); // 这将不会通过编译因为const char * 不符合 void dabble(char * bits); 丢失了const修饰符
dabble(p2); // 符合 void dabble(char * bits);
drivel(p1); // void drivel(const char * bits);
drivel(p2); // void drivel(const char * bits);
// const 参数也是接受const和非const参数，而非const参数只能接受非const参数
```

**在函数名和函数特征标相同，则函数一定相同，函数返回值类型不能区别函数**

以下代码将不能通过编译

```cpp
int square(int x);
long square(int x);
```

**重载引用参数**

```cpp
// 函数原型
void stove(double & r1);
void stove(consr double & r2);
void stove(double && r3);
// 函数调用
double x = 55.5;
consr double y = 32.0;
stove(x); // -> void stove(double & r1);
stove(y); // -> void stove(consr double & r2);
stove(x + y); // -> void stove(double && r3);
// 如果未定义右值引用，则函数将会调用 void stove(consr double & r2); 并创建临时变量，详见上文引用
```

### 何时使用函数重载

虽然函数重载很吸引人，但是也不要乱用。仅当函数基本执行相同的任务，但使用不同形式的数据的时候才使用函数重载

**函数重载的秘密：名称修饰**：C++如何跟踪重载函数，他给这些函数制定了秘密身份，使用C++编译器编译函数的时候，他会使用一些神奇操作----名称修饰。他根据函数原型种植钉的形参类型和顺序进行加密

```cpp
// 函数名称
void print(double a);
void print(int a);
// 内部标识
__Z5printd 
__Z5printi
```





