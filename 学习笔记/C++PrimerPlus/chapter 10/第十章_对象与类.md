# 第十章 对象和类

**面对对象编程(OOP)**是一种特殊的，设计程序的概念性程序方法，C++通过一些特性改进C语言，使得使用该项方法更容易。下面列出了**OOP的重要特性**

1. 抽象
2. 封装和数据隐藏
3. 多态
4. 继承
5. 代码复用性

为了实现上述特性，C++所做的重要的改进就是提供了类。

## 过程性编程和面对对象编程

> 参考链接 From Wiki
>
> https://zh.wikipedia.org/wiki/面向对象程序设计
>
> https://zh.wikipedia.org/wiki/过程式编程

看一个例子来看过程性程序员和面对对象程序员的思考同一个程序，足球队的新成员要求记录球队的统计数据。

如果是过程性程序员，我要输入每名球员的姓名，平均射门次数，平均命中率，以及其他的重要的数据。我希望main调用一个函数来获取数据，调用另外一个函数来计算，调用第三个函数来计算，是不是要添加一个函数来显示菜单，提供选择。总之在过程性编程方法时，首先要考虑遵行的步骤，然后考虑如何表示这些数据

但是如果换成一个OOP程序员，又将如何，就像面对对象名称所示，第一件事情就是考虑**数据**，不仅考虑如何表示表示数据还要考虑如何使用数据。我要跟踪的是什么当然是选手，需要有一个对象来表示选手的各个方面。首先就是基本数据单元，名字，平均射门次数，然后我需要添加一些处理这些数据的方法，其次程序应该能够自动计算命中率而不需要人工干预，另外还需要一些更新和显示信息的方法，所以**用户和数据交互有三种方式，初始化，更新和报告 --- 这就是用户接口**

总之，从OOP的角度考察，首先从用户的角度考察对象---**描述对象所需的数据以及描述用户与数据交互所需的操作**，完全对接口的描述1后需要确定如何实现接口和数据储存，最后使用新的设计方法创建出程序。

## 抽象和类

### 类型是什么

**内置类型指定3件事情**

1. 决定数据对象需要的**内存数量**
2. 决定如何**解释内存中的位**，long和float数据位数相同，但是转换为数据的方法却不一样。
3. 决定可使用数据对象执行的操作和**方法**

内置类型有关操作的信息被内置到编译器中来，但是C++中定义用户自定义的类型的时候，必须自己提供这些信息。

#### C++的类

**类是一种将抽象转换为用户自定义类型的C++工具,他将数据表示和操纵数据的方法组合成一个整洁的包**。

**如何定义类**，一般来说类规范由两个部分组成：

1. 类声明：以数据成员的方式描述数据部分，以成员函数（也被称为方法）的方式描述公有接口。
2. 类方法定义：描述如何实现类成员函数

简单来说类声明提供了蓝图而方法定义了提供了细节

---

#### 什么是接口

> 接口 参考链接 From Wiki
>
> https://zh.wikipedia.org/wiki/接口

接口是一个共享框架，共两个系统交互时使用。

对于类来说，我们说公共接口，在这里公众是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法构成。接口能让程序员编写与类对象交互的代码，从而能让程序使用类对象。如果希望更人性化，不要讲使用的类的程序视为公共用户而将编写程序的人视为公共用户，然而要使用某个类必须要了解其公共接口，要编写类，必须创建公共接口。

---

**为开发一个类**和编写使用的类的程序通常需要多个步骤，首先C++程序员将接口（类定义）放在头文件中，然后并将实现（类方法的代码）放在源代码文件中。而且通常类的名称的首字母大写。

```cpp
class Animal {
    private:
    string name;
    string belong;
    public:
    void vsetname(const string& name);
    const string& name();
    void setbelong(const string& belong);
    const string& belong();
}
```

**C++ 关键词class指出这些代码定义了一个类设计（不同于模版参数此处的class和typename完全不同）**,如此声明了stock为新的类型名，接下来可以在花括号中描述数据成员和成员函数，成员函数可以就地出现，也可以仅描述其原型。但对于描述函数接口而言原型就够了，**将数据和方法组合成一单元是类最吸引的人地方**

### 访问控制

关键词 $private$和$public$也是新的，它们描述了对类成员的访问控制，使用类对象的程序都可以直接访问公有部分，但只能通过共有函数成员函数（或者友元函数，之后关于访问控制不再复述友元函数，将在后面章节详细描述），来访问的类的私有成员，因此**公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口**，**防止程序直接访问数据被称为数据隐藏**,C++还提供了$protected$访问控制符，将在讲到继承的时候提及

类设计尽可能将公有接口和实现细节分开，公有接口表示设计的抽象组件.**将实现细节放在一起并将它们与抽象分开叫做封装**.数据隐藏(将数据放在类的私有部分)是一种封装。将实现的细节隐藏在私有部分中也是一种封装，将类声明和类成员函数定义分开也是封装。

---

#### OOP与C++

OOP是一种编程风格，从某种角度来说，他用于如何一种编程语言中，然而C++中包含了许多专门用来实现OOP的特性，他使得程序员更近一步，首先将数据表示和函数原型放在一个类声明中，而不是放在一个文件中，，其次让数据表示为私有，使得数据只能被授权的函数访问。

---

**数据隐藏不仅可以防止直接访问数据，还让开发者类的使用者不用了解数据是如何被表示的**，需要知道成员函数接受什么样的参数以及返回什么样的值，原则是将实现细节从接口设计中分离出来，如果以后找到了更好的实现数据表示或成员函数的方法，可以对这些细节进行修改，而无需修改程序接口，这使得程序维护更加容易。

#### 控制对成员的访问，公有还是私有

**无论是类成员还是成员函数，都可以在类的公有部分或者私有部分中声明它**，但由于隐藏数据是OOP主要目标，因此**数据项通常放在私有部分，组成类的接口的成员函数放在公有部分，否则用户将无法调用这些函数**。但是也可以将一些成员函数放在私有部分，不能直接从程序调用但是公有成员函数却可以使用它们。**程序员通常使用私有成员函数来处理不属于公有接口实现的细节**

**如果前面没有任何访问控制符，类默认访问控制为私有。**

---

#### 类和结构

类描述很像包含成员函数以及$public$和$private$的可见性标签的结构声明，实际上C++对结构进行拓展了，现在**结构与类的唯一区别，结构的默认访问控制是公有而类是私有。**

**C++通常使用类来实现的类的特性，而使用结构来表示存粹的数据对象,即不包含成员对象(POD)。****

### 实现类的成员函数

实现类的第二个步骤就是为**在类声明中的函数原型提供代码**，成员函数定义与常规函数非常类似，它们有函数头与函数体，也有返回类型和参数，但是它们还包含两个特殊的特征

1. 定义成员函数**使用作用域解析符($::$)来标识函数所属的类**
2. **类方法可以访问类的$private$组件**

首先成员函数的函数头使用作用域解析符来指出函数所属的类 如下所示

```cpp
void Stock::update(double price);
```

上述代码表示update函数是Stock类的成员函数。

因此作用域解析运算符确定了方法定义对应的类的身份，我们说标识符update()具有类作用域。Stock类的其他成员函数不必使用作用域解析符号，就可以使用update方法，因为它们属于同一个类。**类方法的完整名包含类名，我们说 Stock::update()是函数的限定名，而简单的update()是全名的缩写（非限定名），他只能在类作用域中使用。**

#### 内联方法

其定义位于类声明中的函数都将自动成为内联函数，类声明通常将短小函数的作为内联函数。如果希望也可以在类声明之外定义内联成员函数，只需要在定义函数的使用$inline$关键词就可以了,内联的函数的特殊规则要求在每个使用它的文件中都进行定义，为了确保内联定义对多文件程序中的所有程序可用，最简便的方法是在类声明定义内联函数

#### 方法使用哪个对象

如何创建类对象，最简单的方法是**声明类变量**

```cpp
Stock apple,google;
```

如何**使用成员函数**

```cpp
apple.show();
google.buy(20,12.99);
```

**调用成员函数**他将使用被用来调用它的对象的数据成员

**所创建的每个对象都有自己的存储空间，用于存储其内部变量和类成员，但是所有的类的对象共享同一组类的方法。即每一个方法只有一个副本（遵循函数是静态的法则）。也就是说它们将执行同一个代码块，只是将这些代码块用于不同的数据，在OOP中调用成员函数被称为发送信息**

### 使用类

C++的目标是使得使用类和使用基本的内置类型尽可能相同，要创建类对象，可以声明类变量或者使用new为类对象分配内存空间，还可以将一个对象赋值给另一个等等等...

---

#### 客户/服务器模型

OOP程序员常依照客户/服务器模型讨论程序设计，在这个概念中客户是使用类的程序，类声明（包含类方法）构成了服务器，他是程序可以程序可以使用的资源。客户只能通过公有方式定义的接口使用服务器，这意味着客户的唯一职责就是了解该接口，服务器的责任是确保该接口可靠和准确的执行，服务器设计人员只能修改接口的实现接口，而不能修改程序，这样程序员独立的对客户和服务器进行改进，对服务器的修改不会导致对客户的行为以外的影响。

---

### 小结

**指定类设计的第一步是提供类声明**，类声明类似于结构声明，可以包含数据成员和函数成员，声明有私有部分，即只能被成员函数（或者后面提及友元）访问，声明还具有共有部分，在其声明的成员可以直接使用类对象访问，**通常类数据成员被放在私有部分，称函数函数被放在公有部分**

**公有部分的内容构成了设计的抽象部分---公有接口**，将数据封装到私有部分可以保护数据的完整性，这被称为数据隐藏。C++通过类设计使得抽象数据隐藏封装等OOP特性很容易实现。

**指定类设计的第二部是实现类成员函数**，可以在类声明提供函数定义而不是函数声明（除非函数很小可以被作为内联函数），但是通常的做法是在类声明中提供函数声明。在这种情况需要通过作用域解析符来指出成员函数属于哪个类。

**要创建对象（或者说类的实例）只需要用类名作为类型名。**

**类的函数可以通过类的实例来调用，需要使用点号运算符。**

## 类的构造函数和析构函数

对于大多数的类，都应该为类提供构造函数和析构函数，**问题是为什么需要这种函数**：C++的目标之一就是让使用类对象类似于使用内置的标准类型一样。然后到现在为止我们还无法直接在声明的时候直接向初始化结构或者数组一样初始化类。

```C++
int a = 1;
struct car {
    std::string name;
    int years;
};
car c{"Moon",3200};

class pen {
    std::string brand;
    int price;
};
pen p{"Hero",1999}; // 不被允许因为brand和price都是私有成员！ 如果声明为公共成员就可以但是违反了OOP的数据隐藏原则。
```

上述例子因为程序无法直接访问类私有成员，必须要通过成员函数才能访问，那么要如何解决这种问题呢，**C++提供了一个特殊的函数叫做构造函数，专门用于构造新对象，将值赋给他们的数据成员**，更准确的说C++为这些成员函数提供了名称和使用语法，而程序员需要为其提供定义，**名称与类名相同**，构造函数的原型和函数头有一个有趣的特征，虽然**没有返回值**，但没有被声明为void，实际上构造函数没有被声明类型（实际上构造函数只能在创建类对象时自动被程序调用，程序员无法调用，所以返回值没有任何意义，即没有人可以接受他的返回值)

### 声明和定义构造函数

来看car类的一个允许的构造函数 

```cpp
car(const std::string& carname,int price); // 需要注意的是第一没有返回值，第二名称与类名一致

car(const std::string& carname,int price){
    name = carname;
    this->name = name;
}
```

---

#### 成员名和参数名

不熟悉的构造函数的您会使用类成员名称作为构造函数的参数名，如下所示

```cpp
car(const std::string& carname,int price);
```

如果你最终在定义中写出如下代码就是错误的,根据局部变量覆盖全局变量的原则，如下语句就是把函数形式参数price赋值给自己

```cpp
price = price;
```

有两种办法解决这个问题

1. 更改成员函数名称 加上下划线或者跟上m_前缀 如 

```cpp
_price;
_name;
//或者
m_price;
m_name;
```

2. 或者如上述构造函数所示，通过this指针显示指定类成员

```cpp
this->name. = name; // 前面name被显示指定为类成员，而后面的根据局部变量覆盖全局变量是函数形式参数
```

<img src="/Users/llonvne/Library/Application%20Support/typora-user-images/image-20220214105127783.png" alt="image-20220214105127783" style="zoom: 50%;" />

在现代IDE中（如图为2022版本的Clion）往往类成员被颜色显示标出。

### 使用构造函数

C++提供两种办法来使用构造函数初始化对象的方式

**显示调用构造函数**

```cpp
car c = car("Mango",1900);
car c("Mango",1900);
// 或者使用new分配内存
car * c = new car("Mango",1900);
```

但是无法显示调用的构造函数，因为在构造对象前，对象是不存在的，所以构造函数只被创建对象，而不能通过对用来调用。

### 默认构造函数

**默认构造函数是在未提供显式初始值的时候，用来创建的对象的函数，**也就是说他用来创建下面声明的类对象。

```cpp
car c;
```

**这种语句的管用的地方在于如果没有提供任何构造函数C++将自动提供默认的构造函数，他是默认的构造函数的隐式版本，不做任何工作**，显示版本一般为

```cpp
car(){ };
```

如同创建int都是不提供初始值一样。

```cpp
int x;
```

奇怪的是，**当且仅当没有定义任何构造函数时，C++编译器才会提供默认的构造函数，一旦为类定义了构造函数后，如果还想使用上述声明就必须手动提供默认构造函数**，如果提供了非默认的构造函数，但是没有提供默认构造函数一下声明将会出错。

```cpp
car c // 不被允许
```

这样做的原因无非就是**C++编译器认为一旦程序员提供了构造函数就应该完全符合程序员的构造函数来构造**，从而不提供默认构造函数，来防止不被初始化的对象。

定义默认构造函数的方式有两种，一种是为构造函数的所有参数设置默认值，第二种方式是通过函数重载提供一个没有参数的构造函数，如下

```cpp
// 为所有参数设置默认值
car(const std::string& carname = "undefined",int price = 0){
    name = carname;
    this->price = price;
}
// 没有参数构造函数
car(){ };
// 没有参数的构造函数
car(){
    name = "undefined";
    this->price = price;
}
```

提供了上述任何一种构造函数都可以直接声明对象，而不必初始化。

**一般来说在设计类的时候，我们都会提供默认构造函数，不然你将无法按以下方式创建数组等容器，除非你为所有元素全部初始化**

```cpp
car c[1000]; // 如果没有默认构造函数将不被允许
```

```cpp
car c;// 正确 自动调用了默认构造函数
car c(); // 错误你将声明一个返回值为 car 函数名为 c 没有任何参数的函数，而不是创建对象
```

**隐式的调用默认构造函数时不要用括号，用括号必须要有显示的参数**。

### 构造函数

用构造函数创建对象时，程序负责跟踪该对象，直到其过期为止，**对象过期时程序会自动调用一个特殊的成员函数---析构函数**，析构函数完成清理工作，**如果构造函数或者其他类成员函数使用new来分配内存，那么析构函数负责释放这种内存**，也就是说如果构造函数或者其他函数**没有使用new分配内存**，那么**析构函数实际上没有事情可做**。只需要编译器生成什么都不做的隐式析构函数即可。

**析构函数用于释放类中用new分配的内存，自动变量会自动释放，不需要也无法使析构函数介入**

和构造函数一样，**析构函数的名称也很特别，在类名加～，同样没有返回值也没有声明类型**，但是与构造函数稍作区别的，**析构函数没有参数**,下面就是car类的析构函数的声明.

```cpp
~car();
```

**什么时候调用析构函数呢，这通常由编译器决定，通常不应该在代码中显式调用的析构函数（可以但一般不）**。如果创建的是静态存储对象，则析构函数会在程序结束被调用，如果是自动存储类对象，则其析构函数会在程序执行完代码（该变量被声明）块后被调用。在这种情况下程序会自动调用析构函数。。

**由于在类对象过期后析构函数会被编译器自动调用，所以必须要存在一个析构函数，如果程序员没有显示的提供析构函数，那么编译器将隐式的声明一个默认构造函数后**（就是啥事都不敢的构造函数）并在发现对象被删除的代码后生成该定义。

---

**在默认情况（没有重载赋值运算符）将一个对象赋值给同类型的对象，C++将原对象的内容复制到目标对象的相应数据成员中。**

来看两条语句

```cpp
car car1 = car("Mango",1900);
car2 = car("Mango",1900);
```

第一句话是初始化，他可能会创建一个临时对象（这通常取决于编译器实现），第二个是一定会创建一个临时对象。

### C++11 列表初始化

在C++11中可以将列表初始化语法用于类吗，可以，只要有匹配的构造函数，就可以实现，看下面实例。

```cpp
car car1("Mango",1999);
car car1 = car1("Mango",1999);
car car1{"Mango",1999};
```

如上三条语句完全等价。

另外C++11还提供了名为$std::initialize_list$的类，可将其用作函数参数或者方法参数的类型，这个表示任意长度的列表，只要类型都相同，或者可以表示为同样长度的类标。

### $const$ 成员函数

```cpp
// 看下面的car类的成员函数 show
void car::show(){
    cout << this->name << " " << this->price << endl;
}

// 函数调用
const car car1{"Mango",1999};
car1.show();
```

**编译器将拒绝调用$show$函数因为该函数无法保证不修改$car1$里面的内容**，在一般的函数中解决的问题的方法往往是将参数列表的参数声明为常量，但是这个函数没有参数,相反它的参数是通过方法调用隐式提供的。**需要一种的新的语法保证函数调用不会修改对象，C++的解决方法是将$const$放在括号后面**。看如下新的$show$函数声明

```cpp
void car::show() const{
    cout << this->name << " " << this->price << endl;
}
```

以这种方法声明和声明的函数被称为$const$成员函数,就像就可能将$cons$t引用和指针作为函数参数一样，只要类方法不修改调用对象就应该声明他为$const$.

### 构造函数和析构函数小结

**构造函数是一种特殊的成员函数，在创建类的对象的时候被调用，构造函数名称与类名相同，可以通过函数重载创建多个构造函数，构造函数没有声明类型。通常构造函数用于初始化类对象里面的成员，确保所有成员都能被合理的初始化。**

```cpp
car(int brand){
	this->brand = brand;
}

car car1{1000};
car car1 = car(1);
car car1(1000);
car car1 = 1000;
```

实际上第四种实例是新类型，之后将介绍如何关闭这种类型，因为他可能带来令人不愉悦的以外，接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值。

**默认构造函数没有参数，因此如果创建对象时没有显示的初始化，则将调用默认构造函数，如果程序中没有显式的提供构造函数，那么编译器将自动提供一个隐式的构造函数，否则必须自己提供默认构造函数，默认构造函数要么没有任何参数，或者为所有参数提供默认值。**

**当对象被删除的时候将会自动调用析构函数，每个类只能有一个析构函数（因为没有参数，所以无法重载），析构函数没有返回类型也没有参数，其名称为类名在前面加上一个~。如果构造函数使用new分配内存，那就必须使用delete释放内存。**

## $this$指针

假设我们要创建一个创建汽车比较函数，通过一个类对象调用，给定比的对象，返回价高者的引用，原型如下

```cpp
const car & higherPrice(const car & c) const;
```

该函数会隐式的访问的一个对象，就是调用这个函数的类对象，会显式访问一个对象，就是函数形式参数的那一个对象，那么问题来了如何返回这个隐式访问的对象呢？看下面的实例

```cpp
const car & higherPrice(const car & c) const{
	return price > c.price ? /* ???这边写什么 */ : c;
}
```

问题在于如何称呼这个被隐式调用的对象，C++给出的解决方法是使用名为$this$的隐式指针，$this$用于只想调用成员的对象（$this$作为隐藏参数传递给方法）那么上述实例可以改写如下

```cpp
const car & higherPrice(const car & c) const{
	return price > c.price ? *this : c;
}
```

 一般来说所有类方法都this指针设置为调用他对象的地址，简单来说

```cpp
// ... car类的某个方法内
price = 1900;
// ==
this->price = 1900;
```

**每一个类或者是结构成员的方法（包含构造函数和析构函数）都有一根this指针，this指针指向调用的对象**，如果想要调用整个对象，只需要对this指针解引用即可！**在函数括号的添加的const实质上是将this指针限定为const，这样就不能使用this指针修改对象的值**，如上所述，所有调用类成员的都是隐式通过this调用的。

## 对象数组

用户通常使用同一个类多个对象，可以创建独立变量。但是创建对象数组更合适，似乎很高级，其实与创建的一般都数组并无区别

```cpp
car cars[1000];
```

**当程序常见未被显示初始化的类对象时，总是调用默认构造函数，上述声明要求要么这个类没有显示的声明构造函数，要么定义一个显示的构造函数。**

当然你也可以为数组中的**每一个元素都显示初始化**，如果声明了默认构造函数你可以对所有的元素初始化或者只对一部分元素初始化。

对

## 类作用域

C++类引入一种新的作用域叫做类作用域，在类中定义的名称（数据成员名或者是函数成员名）的作用域都为整个类，作用域内整个类的名称都是可知的，在类外是不可知的。也就是说在类作用域不可以直接访问类的对象，公有成员函数也是如此，必须通过对象访问。定义成员函数必须使用作用域解析符

总之在定义类声明或者成员函数定义的时候，可以使用未修饰的成员名称（未限定的），在其它情况下要么使用直接运算符号句号，间接成员运算符->或者作用域解析符.

### 作用域为类的常量

有时候使得符号常量的作用域为类很有意义，类声明可能用30来制定数组·的长度，该常量对于所有类都相同，因此创建一个所有类的共享的常量似乎很不错，看一下代码

```cpp
class Cats {
    private:
    const int Len = 10; // 失败
    string catsName[Len];
}
```

上述的常量声明不可行的，因为**声明类只是描述了对象的形式，而不会实际创建对象，在创建对象前将没有用于存储值的空间**（C++11提供了成员初始化，但是不用域前面的数组声明），有两种方法可以实现这个目标

第一种方法就是声明**枚举**，在类声明中声明的枚举作用域为整个类，而因此可以用**枚举常量为整形变量提供作用域为整个类的符号名称**看如下代码

```cpp
class Cats {
    enum {CatsCount = 12}
    string catsName[CatsCount];
}
```

这里的$CatsCount$只是枚举常量当编译器遇到改名称将用12替换他。

当然C++提供了第二种方法来创建常量就是$static$，如下面所示

```cpp
class Cats {
    static const int CatsCount = 12;
    string catsName[CatsCount];
}
```

该变量将与自动变量存储在一起，而不是存储在对象中，因此只有一个CatsCount变量，在C++98中只能使用static声明为枚举或者整数的静态常量，在C++11中消除了这种限制

### 作用域内枚举(C++11)

传统的枚举可能存在一些问题，可能两个枚举量会存在名称冲突。例如

```cpp
enum egg {Small,Medium,Large};
enum t_shirt {Small,Medium,Large}
```

如果上述出现在同一个作用域中，将无法通过编译，他们将发生冲突，为了**解决这种冲突C++11提供了一种新的枚举类型，其枚举量的作用域为类**，声明如下,在后面追加**$class$表示类作用域枚举**，也可以使用$struct$两者没有区别

``` cpp
    enum class egg {Small,Medium,Large};
    enum class T_shirt{Small,Medium,Large};
```

**声明为类作用域枚举后都需要使用枚举名来限定枚举变量**，如下

```cpp
egg e = egg::Small;
T_shirt t_shirt = T_shirt::Large;
```

**这样即使在不同定义定义的枚举量也不会冲突，同时表以也更加清晰了**

C++11也提高了作用域内枚举的安全性，**在有些情况下，常规枚举自动转换为整形，但是作用域枚举不能隐式的转换为整形**

```cpp
enum normal {Small,Medium,Large};
enum class scoped {Small,Medium,Large};
normal n = Small;
scoped s = scoped::Small;
std::cout << n; // 隐式的转换为整形
//std::cout << s; // 无法隐式的转换为整形，会报错
std::cout << (int)s; // 可以显式的转换为整形
```

枚举底层用数字表示，在C++98中如何选择取决于实现，对于作用域枚举，C++11取消了这种限制，在默认情况下作用域内枚举类型为int，可以显式的指定类型如下

**此处C++PrimerPlus书本提供的语法无法编译，经测试应该是如下语法**

```cpp
// C++PrimerPlus提供的语法，无法通过编译
enum class : short Egg {Small, Medium, Large};
// 能够通过编译的语法
enum class Egg : short Egg {Small, Medium, Large};
```

## 抽象数据类型

前面定义的$car$类非常具体，程序常常通过定义类表达更加通用的概念，就抽象数据类型ADT的而言，使用类是非常好的概念，顾名思义ADT以通用的方式来描述数据类型，而没有引入语言和实现细节，例如栈。

我们不妨以栈为例，来看看如何描述一个抽象数据类型

具有的操作

1. 可以创建空栈
2. 可以讲数据项添加到栈顶
3. 可以讲数据项从栈顶删除
4. 可以查看栈是否填满
5. 可以查看栈是否为空

来看下面实例

```cpp
typedef int Item;
class Stack{
private:
    enum class Stack_Size {Small = 10,Medium = 100,Large = 1000};
    Item _ItemArr[(unsigned long)Stack_Size::Large];
    int top;
public:
    Stack();
    bool isEmpty() const;
    bool isFull() const;
    bool push(const Item&);
    bool pop(Item&);
};
```

私有部分表明改栈是由数组实现的，而公有接口隐藏了这一点，所以即使程序兴致大发，合理的改为new实现，对于外部使用者来说也没有任何区别，而为了栈通用，使用了typedef来定义数据类型，在后面我们会学到类模版来更好实现的这一点。

**通过私有化数据成员来保证各个数据项能被成员函数正确的处理，这种保证措施是OOP更加可靠的之一**。

## 总结

面向对象编程强调的是程序如何使用数据，使用**OOP方法解决编程第一步是根据他与程序的接口来描述数据**.从而制定如何使用数据。然后设计一个类来实现该接口，一般来说**私有数据成员存储信息，公有成员函数提供访问数据的唯一途径**，类将**数据和方法合成一个单元，其私有性实现数据隐藏。**

一般来说，将类声明分为两个文件存储，一个头文件存储类声明（由函数原型表示的方法），定义成员函数的源代码应该放在源文件中，这样便将接口细节和实现细节分开，从理论来上说只需要查看接口就可以使用类。程序不应该依赖类的实现细节，只要程序与类通过定义接口的方法进行通信，程序就可以随意的对任何部分进行修改，而不必担心导致意外的不良影响。

类是用户定义的类型，对象是类的实例，C++试图让用于定义的类型与内置类型更加一致，提供了许多与普通内置类型相同的操作方法。





