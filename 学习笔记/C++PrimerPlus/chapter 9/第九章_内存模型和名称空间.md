# 第九章_内存模型和命名空间

## 单独编译

C++允许甚至**鼓励程序员将组件函数放到独立的文件中**，在C++中可以单独编译这些文件，然后将它们链接成可执行的程序。（一般来说C++编译器及编译程序也管理链接器）

但是问题来了到底如何划分一个程序放到多个文件中，难道就是简单的讲他们分开吗？假如一个文件中包含了一份结构定义，那么如果在另一个文件也想使用这个定义，那就必须要包含结构声明，那随着使用的文件数量增多，就会出现相当声明，万一想要修改声明，难道要修改这么多份吗？所以**与其将其这么多声明单独的放到文件中，不如放在头文件中（.h）**,然后在每一份源码包含这一份头文件，这样修改声明的时候只需要在头文件做一次修改就可以了。

**所以可以将原来的程序分成三部分**

1. 头文件：包含结构声明和使用这些结构的函数的原型
2. 源代码文件：包含与结构相关的函数的代码
3. 源代码文件：包含调用与结构相关的函数的代码

**请不要将包含函数定义或者变量声明放到头文件中**，对于简单的可能可行，但是对于两份文件包含同一份头文件，会导致程序包含两个该程序的定义，除非函数是内联的否则将出错。

---

**头文件应该包含的内容:**

1. 函数原型
2. 使用 #define 或者 const 定义的符号常量
3. 结构声明
4. 类声明
5. 模版声明
6. 内联函数

将结构声明放在头文件是可行的，因为它们不变量，而是只是在源文件中创建结构时，告诉编译器如何创建该结构。

模版声明不是将被编译的代码，他只是告诉编译器如何生成与源代码中函数调用相匹配的函数定义。

被声明位const的数据和内联函数具有特殊的属性，被放在头文件不会引起问题

---

**在包含自己的头文件时候应该是用 "" 而不是 <>**

**在使用指令编译的时候只需要添加源代码文件而不需要头文件，这是因为 #include 会自动添加头文件**

**请不要使用 #include 来包含源代码文件，这样做会导致多重声明**

---

**头文件管理**

在同一个文件中只能将同一个头文件包含一次。但是很可能在不知情的情况包含了多次，例如可能使用另外一个头文件的头文件。有一种**C/C++标准技术可以避免多次包含同一头文件，他是基于预处理器编译指令#ifndef(if not define)**，下面的代码意味着只有没有定义过 POLAR_H 才执行 if 和 endif 中间的语句

```cpp
#ifndef POLAR_H // 如果没有定义 POLAR_H 执行
#define POLAR_H // 定义 POLAR_H 阻止第二次运行

// ... 

#endif //POLAR_H
```

编译器首次晕倒该头文件,名称 POLAR_H 没有定义 (我们通过文件名+下划线+ H + 下划线来统一命名防止重复).这种情况编译器将会编译中间的代码同时定义 POLAR_H ,如果在另外代码处再次包含头文件，编译器会发现 POLAR_H 已经被定义从而跳过编译。这种方法虽然不能防止头文件被包含两次，而知识让他忽略第一次包含以外所有的内容。大多数C/C++头文件都是用这种防护策略，不然定义多个结构两次可能导致错误。

**在IDE中往往会自动建立这种防护，而无需我们手工写入**

---

### 9.1 & 9.2 & 9.3 多文件编程实例

```cpp
// coordin.h
#ifndef COORDIN_H
#define COORDIN_H
// structures template
struct polar
{
    double distance;
    double angle;
};
struct rect
{
    double x;
    double y;
};
// prototypes
polar rect_to_polar(const rect&);
void show_polar(const polar&);
#endif //COORDIN_H
```

```cpp
// file1.cpp
#include <iostream>
#include "coordin.h"
using namespace std;

int main()
{
    rect rplace;
    polar pplace;

    cout << "Enter x and y value:" << endl;
    while (cin >> rplace.x >> rplace.y){
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Next 2 number:" << endl;
    }
    return 0;
}
```

```cpp
// file2.cpp
#include <iostream>
#include <cmath>
#include "coordin.h"
using namespace std;

// convert rect to polar
polar rect_to_polar(const rect & xypos)
{
    polar answer;

    answer.distance = sqrt(pow(xypos.x, 2) + pow(xypos.y, 2));
    answer.angle = atan2(xypos.y, xypos.x);

    return answer;
}

void show_polar(const polar & dapos)
{
    const double Rad_to_deg = 57.29577951;

    cout << "distance = " << dapos.distance << endl;
    cout << "angle = " << dapos.angle * Rad_to_deg << " degrees" << endl;
}
```

```sh
# 使用 g++ 编译 不需要包含头文件
g++ -std=c++11 file1.cpp file2.cpp -o "xytpolar"
```

多两个源代码文件和新的头文件一起进行编译和链接，将生成一个可执行文件。

虽然我们讨论的是根据文件单独进行编译，但是为了保证通用性，C++标准使用了术语翻译单元，而不是文件。

---

## 存储持续性性，作用域，链接性

**C++使用三种（C++11使用四种）不同的方案来存储时间，四种方案的区别就是数据保留在内存中的时间**

1. 自动存储连续性：在函数定义中声明的变量（包括函数参数）的存储持续性性是自动的。它们在程序开始执行其所属的函数或者代码的时候被创建，在执行完函数或者代码块的时候被释放，C++有两种存储持续性位自动的变量。
2. 静态存储连续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态，它们在整个程序运行时都存在，C++有三种该类型的变量。
3. 线程存储持续型(C++11):不展开讨论
4. 动态存储持续性：用new运算符分配的内存将一直存在知道使用delete运算符将其释放，或者程序结束。这种内存持续性称为动态，有时被称为自由存储或者堆。

---

### 作用域和链接

**作用域**描述了名称在文件的多大范围是可见的

**链接性**描述了名称如何在不同文件（单元）内共享，链接性为外部的名称可以在文件间共享，链接性为内部的变量只能在同一个文件的函数共享。自动变量的名称没有链接性，所以他不能共享。

C++变量的作用域有多种

1. 作用域为局部的变量只在定义它的代码块可用，代码块是用{}括起多行代码
2. 作用域为全局（文件作用域）的变量在变量的定义位置到文件尾部都可以用。
3. 自动变量的作用域为局部
4. 静态变量的作用域取决他如何定义
5. 在函数原型作用域中使用的名称只在包含参数列表的括号中可以用。
6. 在类中声明的成员作用域为整个类。
7. 在名称空间中声明的变量作用域是整个命名空间（由于名称作用域已经引入C++语言，所以全局作用域是名称空间作用域的特例）

---

### 自动存储持续性

在默认情况下，**在函数定义中声明的变量（包括函数参数）的存储持续性性是自动的。作用域为局部，没有链接性，只有当程序执行到变量所在代码块时才为其分配内存，当函数结束时，这些变量都将消失。**（这边注意，执行到代码块的时候为其分配内存，但是作用域的起点是其声明位置）

如果在**代码块中定义变量那么其作用域和持续时间都限定在代码块**中，如果**一个变量名同时在内部代码块和外部代码块定义，我们说新的定义隐藏了旧的定义**，新定义可见，当程序离开该代码块时，原来的定义又重新可见。（该规则也适用于命名空间）

**在C++11中，auto用于类型推断，但是在C语言和C++之前的版本中他用于显示的指出变量为自动存储。用的人太少所以改了**

#### 自动变量的初始化：

可以使用任何在声明时其值为已知的表达式来初始化自动化变量

```cpp
int a = 1;
int b = 2 * a;
```

#### 自动变量与栈

由于自动变量的数目随着函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理，常用的方法是留出一段内存，将其视作栈，以管理变量的增减，子所以被称之为栈，是由于新数据被象征性的放在原有数据的上面，当程序使用完后，将其中栈中删除，栈的默认长度取决实现，但是编译器通常允许你定义长度。

#### 寄存器变量

关键字register是由C语言引入的,他建议CPU寄存器来存储自动变量，这旨在提高变量的访问速度。

在C++11之关键字用法没有变化，这种提示表示这个变量用的很多，编译器可对其进行特殊处理，在C++11中，这种提示作用也失去了，关键词register只是显式的指出变量时自动的，而关键词register本来就只能用自动变量，保留register的原因就是不想让使用了该关键字的代码非法。

### 静态存储持续型变量

C++为静态存储持续性变量提供了3种链接性，分别是**外部链接性（可在其他文件中访问），内部链接性（只能在当前文件中访问），无链接性（只能在当前函数或者代码块中访问）**，这三种链接性都在**整个程序执行时期存在**，与自动变量相比它们的寿命更长，由于静态变量的数目在程序运行期间都是不变的，因此程序不需要使用特殊的装置来管理，**编译器将分配固定的内存块来存储所有的静态变量**；如果没有显示的初始化静态变量，编译器将其设置为0，**默认情况下静态数组和结构的每个元素或成员的所有位都设置为0**.

1. 想要创建链接性为外部的静态持续变量，必须要在代码块外部声明他。

2. 想要创建链接性为外部的静态持续变量，必须要在代码块外部声明他，并添加static修饰词
3. 要创建没有链接性的静态持续变量，必须在代码块内部声明他，并添加static修饰词

```cpp
int a = 1; // 链接性为外部的静态持续变量
static int b = 1; // 链接性为内部的静态持续变量
int main(){
	static int c = 1; // 无链接性的静态持续变量
	return 0;
}
```

上述所有的静态持续变量(a,b,c)在整个程序运行期间都存在。但是在main函数中声明的变量为无链接性的静态持续变量，也就说只能在main内部访问和修改该值。a没有被static修饰又处于外部术语外部链接性的静态持续变量，可在所有文件的访问，而变量b处于代码块外部但是被static修饰，属于内部连续性的静态持续变量，只能在该文件中使用。

**所有未初始化的静态持续变量的所有位都被设置为0，这种变量被称为0初始化的**。

---

**自动和静态持续性变量总结**

|     存储描述     | 持续性 | 作用域 | 链接性 | 如何声明                                  |
| :--------------: | :----: | ------ | ------ | ----------------------------------------- |
|       自动       |  自动  | 代码块 | 无     | 在代码块内部                              |
|      寄存器      |  自动  | 代码块 | 无     | 在代码块内部，且使用register修饰，C11失效 |
|  静态，无链接性  |  静态  | 代码块 | 无     | 在代码块内部，且使用static修饰            |
| 静态，外部链接性 |  静态  | 文件   | 外部   | 不在任何函数中                            |
| 静态，内部链接性 |  静态  | 文件   | 外部   | 不再任何函数中，且使用static修饰          |

我们会发现static在不同场景的意义并不相同，有人称之为关键字重载，即关键字意义取自于上下文。

---

**静态变量的初始化**

除了默认的零初始化外，还可以对静态变量进行**常量表达式初始化**和**动态初始化**

其中**常量表达式初始化和零初始化统称为静态初始化**，这意味者在编译器处理文件的时候初始化变量(编译时初始化)，动态初始化意味者将在编译后初始化。

那么编译器是如何执行初始化的呢，分为下面几步

1. 所有的静态变量都被分配内存和零初始化（无论是否被显示初始化）
2. 如果静态变量使用了常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可以计算表达式，编译器将执行常量表达式初始化，必要时编译器将进行简单运算，如果没有足量信息，变量将被动态初始化。

```cpp
#include <cmath>
int x; // 零初始化
int y = 5; // 静态初始化
long z = 13 * 13; // 静态初始化
const double pi = 4.0 * atan(1.0); // 动态初始化
```

pi因为设计到函数调用所以必须等到编译结束，程序链接后，程序运行时才能进行初始化。

### 静态存储持续性，外部链接性

**链接性为外部的变量通常简称为外部变量，它们存储持续性为静态，作用域为整个文件**，外部变量是在函数外部定义的，所以对于所有函数而言都是外部的。外部变量也可称为全局变量。

#### 1. 单定义规则

一方面，**在每个使用外部变量的文件，都必须声明他（一般由头文件#include完成）**,另一方面C++有**单定义规则**该规则指出变量只能有一次定义，为了满足这种需求，C++提供了两种变量声明，一个是定义声明简称为定义，该操作将为变量分配内存空间，另外一种是引用声明简称为声明，他不给变量分配空间，因为他引用已有的变量

**不难看出，单定义规则就指的是只能为同一个变量分配一次内存**

**引用变量使用关键词extern，且不进行初始化，否则声明为定义，导致分配存储空间**

---

实例1

```cpp
double up; // 定义 up初始化为0
extern int blem; // 声明 不分配内存 blem将在别处分配内存
extern char gr = 'z'; // 定义 被初始化需要分配内存空间 
```

实例2

```cpp
// file1.cpp
extern int cats = 20; // 定义 被初始化需要分配内存空间 == int cats = 20;
int dogs = 22; // 定义
int fleas; // 定义
// file2.cpp
extern int cats; // 声明从1处引用cats
extern int dogs; // 声明从1处引用dogs;
// file3
extern int cats; // 声明从1处引用cats
extern int dogs; // 声明从1处引用dogs;
extern int fleas;// 声明从1处引用fleas;
```

在2和3都用声明引用了cats和dogs变量，但是2没有声明fleas因此不可使用，其中1的第一句可以省略extern，效果相同

---

请注意**单定义规则并不意味着变量名不能相同**，例如在不同代码块声明的同名自动变量是彼此独立的，它们有自己的地址，另外局部变量可能隐藏同名的全局变量。程序中可包含多个同名的变量，但是每个变量都包含自己的定义。

**在同一个作用域中（不包含其内部的子作用域），只能有一个变量定义**

如果在函数中声明了与外部同名的变量，这种声明将会被视为一个自动变量的定义，当程序执行到自动变量所属的函数时，该变量将位于作用域中。

来看实例

```cpp
// main.cpp
#include <iostream>
using namespace std;

// 外部变量
double warming{0.3};

// 函数原型
void update(double dt);
void local();

int main(){
    cout << "Global warming is " << warming << endl;
    update(0.1);
    cout << "Global warming is " << warming << endl;
    local();
    cout << "Global warming is " << warming << endl;
    return 0;
}
// support.cpp
#include <iostream>
using namespace std;

// 变量声明
extern double warming;

// 函数原型
void update(double bt);
void local();

void update(double bt){
    extern double warming; // 这个声明时可选的，目的是指出使用的外部的warming
    warming += bt; // ::warming
    cout << "Update global warming to " << warming << endl; // ::warming
}

void local(){
    double warming = 0.8; // 
    cout << "local warming = " << warming << endl;
    cout << "but global warming is " << ::warming << endl;
}
```

**定义与全局变量相同的变量名后局部变量将隐藏全局变量**，例如函数定义局部变量warming后，当local函数使用warming时将使用局部版本。

C++比C语言更近一步，**它提供了作用域解析运算符号(::)，放在变量名前面，该运算符号表示使用变量的全局版本。**

从**清晰和避免的错误的角度来**说相对于使用 warming并依赖于作用域规则，在函数update中使用::warming是更好更安全的选择->**使用全局变量:使用 :: 表示**

---

**全局变量和局部变量**

既然可以使用全局变量和局部变量，选哪种呢？-> 首先全局变量很有吸引力，因为所有的函数都可以访问全局变量，不用传递参数，但是**易于访问的代价很大 --- 程序不可靠**，计算经验表明**程序越能避免对于数据的不必要的访问，就越能保证数据的完整性**。通常情况下应当使用局部变量，应当在需要知晓时传递数据，而不是不加区分的使用全局变量，后面我们可以看到**OOP在数据隔离方面又迈进一步**。

然而全局变量并不是一无是处，例如可以让多个函数使用同一块数据，外部数据尤其适于表示常量数据，因为这样可以增加const修饰符，以防数据被修改。

总的来说，**应当在合理的范围内缩小变量的作用域，为变量增加const修饰符**。

### 静态存储持续性，内部链接性

将static限定符用于作用域为整个文件的变量时，该变量的链接性将变为内部的，在多文件程序中内部链接性和外部链接性之间的差别很有意义，连接性为内部的变量只能在所属文件中使用，而连接性为外部的变量可以在所有文件中使用。

这边需要注意的是如果**在一个文件中定义了全局变量a，在另一个文件如果没有进行声明是不能使用，也不能再声明一个全局变量a.**

也就是说下述代码将不会通过编译

```cpp
// file1
int errors = 20;
// file2
int errors = 5;
void froobish(){
    cout << errors;
}
```

这个代码将会编译失败，他违反了单定义原则，记住**外部链接性的作用域是所有文件（即使可能某个文件没有声明导致无法访问，但是作用域仍然覆盖）**，所以即使在不同文件中声明两个同名的全局变量，仍然会导致在同一个作用域（除去子作用域）声明同名的变量导致冲突，违反单定义原则

简而言之**在多文件程序中，可以在一个文件中（也仅能在一个文件中）中定义一个外部变量，使用该变量的其他文件必须（也只能）通过extern声明他**

可使用外部变量在多文件程序中的不同部分共享数据，可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（命名空间提供另外一种方式来共享数据），另外如果将作用域为整个文件的变量修饰为静态的，就不必担心名称与其他文件中作用域为整个文件的变量发生冲突。

**我们可以这样理解，在不引入命名空间的前提下，所有文件之间是最大的作用域，声明的不带static修饰的不属于任何代码块的变量就属于该作用域，而带static修饰的不属于任何代码块的属于单个文件作用域，由于带static修饰的变量的作用域属于所有文件之间作用域的子集，相对于所有文件来说属于局部变量，所以不会发现名称冲突。**

### 静态存储持续性，无链接性

**如何创建该类型的变量**：使用static修饰符修饰在代码块中代码如下所示

```cpp
static int a; // 不是，该代码不处于代码块中
int main(){
    int a; // 不是，该语句不被static修饰
    static char b; // 是的该语句处于代码块中且被static修饰
}
```

在代码块中使用static时会导致局部变量的持续性变为静态的，这就意味着虽然该变量只能在该代码块中可用，但是他在代码块不活跃的时候持续存在（他将会在**整个程序进程中一直存在，无论是否活跃，且被初始化**）。因此在**两次函数之间，变量值可以保持不变**。另外静态变量**只会在程序启动时被初始化**（如果程序员没有显示初始化，编译器将会自动将其零初始化），而**不是每次程序调用都被初始化**。

### 说明符和限定符

有些被称为**存储说明符**,或者是**cv限定符**

**存储说明符如下**

```cpp
auto; // 在C++11（不包含C++11）之前表示自动变量，C++11中用于自动类型推导，即C++11（不包含C++11）是存储说明符号，C++11（含C++11）以后不再是存储说明符
register; // 在C++11（不包含C++11）表示寄存器变量，在C++11(包含C++11)之后仅表示自动自动变量
static; 
extern;
thread_local; //(C++11新增)
mutable;
```

除了thread_local可以跟extern和static结合外，在同一个声明中不可以出现多个修饰符号。

除了thread_local和mutable没有认识外，其他均在前面有说明

**cv-限定符号**

```cpp
const; 
volatile; 
```

其中const表示当变量内存被初始化后，程序不能再对其进行修改。

而**volatile表示即使程序代码没有对其进行修改，其值仍然可能发生变化**。，该关键词的作用主要是更改编译器的优化能力，一般来说在一个程序中同时使用一个值两次，程序可能不是将其读取两次，而是第一次读取时顺手存到寄存器，第二次直接从寄存器取出，这种假设没有外部程序会影响该值，但是如果使用**volatile修饰变量，编译器将每次重新读取该值**。

**mutable成员表示即使某个类或者成员为const，其中被mutbale修饰的成员也可以修改**，实例如下

```cpp
struct data{
    char name[100];
    mutable int accesses;
};
const data d = {
    "Llonvne",
    0
};
strcpy(d.name, "Lcosvle"); // 不被允许 d 为常量其成员不允许修改
d.accesses++; // 允许 虽然d 为常量，但是accesses被mutable修饰所以可以修改。
```

**在C++中（此处不包括C语言），const对默认存储类型稍有影响，在默认情况下全局变量的链接性为外部的，但是被const修饰的全局变量的链接性为内部，也就是说在C++看来，全局const定义类似于使用了static修饰符号一样**,下述两句语句完全等价

```cpp
const int a = 1;
const static int a = 1;
```

C++修改了常量类型的规则，使得程序员更加轻松，假设将一组全局常量放在头文件，并在同一个程序的多个文件中使用这样的头文件，那么处理器将头文件包含到所有的源文件后，所有的源文件都将包含一份全局常量定义，**如果全局的链接性是外部的，根据前面的单定义规则，这将出错**，也就是说只有一组文件可以包含定义，而另外的文件必须使用extern来引用变量。另外只有未包含extern关键字的才能进行初始化。**这将导致许多不必要的麻烦。**

因此，**需要为某个文件使用一组定义，而其他文件使用另外一组声明，然而由于外部定义的const数据的链接性仍然是内部，因此可以在所有文件使用相同的声明。**所以C++鼓励将const声明写入头文件，由于const内部链接性，他不会违反单定义规则。

如果出于某种特殊的原因，需要某个常量的链接性为外部的，可以使用extern来修饰const常量，这将覆盖原来的const的内部链接性。

```cpp
extern const int a = 0;
```

这种情况该变量与普通的外部链接性变量使用方法基本一致（除了他是常量），也就是必须在所有使用它的文件中使用extern声明他。

下述表格说明了与普通外部变量的区别

| 类型                        | 定义方法                                    | 链接性     | 其他文件的使用方法                                           |
| --------------------------- | ------------------------------------------- | ---------- | ------------------------------------------------------------ |
| 常规外部变量                | 在所有代码块外部定义                        | 外部链接性 | 使用extern声明变量后使用                                     |
| const外部变量（内部链接性） | 在所有代码块外部定义，且被const修饰         | 内部链接性 | 如果包含了声明const外部变量的头文件，可以直接使用。          |
| const外部变量 (外部链接性)  | 在所有代码块定义，且被const和extern同时修饰 | 外部链接性 | 同时使用extern和const变量引用变量，且引用常量只能在一处初始化。 |

，如果在代码块内部创建常量，只有在该代码块中常量可用。

### 函数与链接性

与变量一样，**函数也有链接性**，虽然选择范围稍小，与C语言一样，C++不允许在一个函数中定义另外一个函数，因此**所有函数的存储持续性都是静态的**，即在程序执行期间一直存在，在**默认情况下函数的链接性为外部，可以在所有文件中共享**（与全局变量一样需要声明，实际上也可以与全局变量一样，**用extern显式的指出该函数在其他文件处定义**）。与全局变量一样的是也可以**使用static修饰函数使得函数链接性变为内部的**，使之只能在一个文件中使用。必须在原型和定义都使用static修饰。

使用static函数只在该文件中文件可见，还意味着在其他文件中可以定义同名函数，与全局变量一样，**局部函数可以覆盖全局函数**

即使外部定义了全局函数，如果该文件中存在static同名函数，程序仍将使用static修饰的函数。

**单定义规则也同时适用于非内联函数，因此对于所有的非内联函数程序只能包含一个定义**，对于链接性为外部的函数来说，这意味着在多文件程序中，只能有一个文件包含该函数的定义，但是**所有使用该函数的文件都应该包含其函数原型**。

内联函数不适用于上述规则，这将**允许程序员将内联函数放入头文件中**，这样包含头文件的每个文件都有了内联函数定义，但是**C++要求内联函数的定义全部相同**.

#### C++在哪里查找函数

假设程序调用了一个函数，那么C++如何查找函数的定义呢？如果文件中函数的原型指出该函数是静态的，程序将只会在该文件中查找函数定义。否则程序将在所有文件中查找定义。如果找到两个定义，即报错，如果没有在文件中找到，C++将去库中搜索。这意味者如果**程序定义了与库中同名的函数，C++将使用程序员定义的版本**,

### 语言链接性

链接程序要求每个不同的函数都有不同的函数符号，在C语言中一个名称只对应一个函数，这很容易实现，为了满足内部需要，**C语言一般将main函数翻译为_main，这种方法叫做C语言链接性**,但是在C++中一个函数可能多个函数，必须将这些函数翻译为不同函数符号，为此C++将执行名称修饰，为重载函数生成不同的函数符号

```cpp
// C
main() -> _main
print(double); -> _print;
// C++
main() -> _main;
print(int); -> _print_i;
print(double) -> _print_d;
```

C++这种方式叫做C++语言链接，链接程序寻找与C++函数调用匹配的函数时，方法与C语言不同，如果要在C++程序中使用C库预先编译好的函数，会有如下所示

```cpp
spiff(22); // want spiff(int) from a C library
/*
他在C库文件中的符号名称为_spiff，对于我们假设的链接程序来说，C++查询符号名称是_spiff_i对于这种方法，我们可以用函数原型指出要使用的约定
*/
extern "C" void spiff(int); // C
extern "C++" void print(int); // C++
extern "C++" void print(double); // C++
```

C,C++是C++标准指定的说明符号，但实现可提供其他语言链接性说明符号。

**这边很重要的一点是该库程序必须使用C编译器编译的库才需要指定查找约定，如果将C语言程序源码直接在C++编译器通过编译，他将默认使用C++查找约定，既不需要查找约定，简单来说一定是经过C语言编译器的库才需要语言查找约定**

### 存储方案和动态分配

前面介绍的C++为内存分配的5种方案（线程内存除外）他不适用于C++运算符new（或者C函数malloc）分配的内存，这种内存称为动态内存。动态内存由new和delete控制，而不是由作用域和链接性规则控制，因此可以在一个函数中非配动态内存，而在另外一个函数中释放。编译器使用三种独立内存，一块用于静态变量，一块用于自动变量，另外一块用于动态存储。

虽然存储方案不适用不适用于动态内存，但是适用于跟踪动态内存的自动和静态的指针，如下

```cpp
flaot * p_fees = new float(20);
// 由new分配的内存将一直保留在内存中，但是p_fees指针将在代码块结束后被释放，如果还有继续使用该内容，必须传递改地址或者返还给调用函数。或者将指针声明为全局变量，令所在该声明之后的函数都可以使用它，在另外一个文件使用下述声明也可以使用
extern flaot * p_fees;
```

**一般来说由new分配的内存通常都会在程序结束时都被释放，不过情况并非一直如此，在不那么健壮的操作系统中，在某些情况的情况下请求的大型内存可能不会被自动释放，最佳的情况下使用delete来释放由new分配的内存**

> 请不要丢失控制内存的指针，否则会导致内存泄露
>
> https://zh.wikipedia.org/wiki/内存泄漏

#### 使用new元素符初始化

如果要为**内置的标量类型**，如int或者double初始化并初始化，可在**类型名加上初始值并用括号括起**，实例如下

```cpp
int * p_int = new int(-1);
```

这种**括号语法**也可以适用于由**合适构造函数的类**。

在新的**C++11*中，可以使用*大括号的列表初始化常规结构或数组，也可以初始化单值变量**；实例如下

```cpp
int * a = new int[10]{1,2,3,4,5,6,7,8,9,0}; // 使用大括号初始化数组
struct person {
	char name[1000];
	int age;
};
person * p = new person{"Llonvne",19}; // 使用大括号初始化结构
int * b = new int{2}; // C++也可以用大括号初始化单值变量与C++98括号类似
```

#### 当new失败的时候

new可能找不到请求的内存量，在最初的十年中，C++让new返回空指针（与malloc相同），现在将引发异常:std::bad_alloc,

#### new，运算符，函数，替换函数

运算符new和new[]分配调用如下函数

```cpp
void * operator new (std::size_t);
void * operator new[] (std::size_t);
```

这些函数被称为分配函数，位于全局名称空间中，同样也有释放函数如下

运算符delete和delete[]分配调用如下函数

```cpp
void operator delete (void *);
void operator delete[] (void *);
```

它们使用第十一章使用的运算符重载的语法 如下所示

```cpp
int * pi = new int;
int * pr = new(sizeof(int)); // ==

int * pa = new int[40];
int * pa = new(sizeof(int) * 40); // ==
```

delete也基本一致。

有趣的是C++讲这些函数称为可替换的，意味者你有足够的知识和意愿可为new和delete提供替换函数，并根据需要进行定制，例如可定于作用域为类的替换函数。在代码中仍然使用new运算符，但他将调用您定义的new()函数

#### 定位new运算符

通常，new负责在堆中找到一个能够足以满足的要求的内存块，new运算符号还有另外一种变体，被称为定位new运算符，它能让你指定要使用的位置，程序员可能使用这种特性来设置内存管理规章，处理需要通过特定地址进行访问或在特定位置创建对象。

要使用定位运算符要包含头文件new,他包含了这种版本new运算符的原型，然后将new运算符用于提供了所需地址的参数，除了需要特殊的地址参数，其余参数类似，具体来说来说使用new运算符可以有方括号也可以没有。

实例

```cpp
char buffer[512];

int * p = new (buffer) int[50]; // 将buffer所在的内存地址分配个int
```

## 名称空间

在C++中名称可以是变量函数结构美剧类和类的结构和成员，**随着项目的增大，名称相互冲突的可能性也可能上升**，当使用多个厂商的类库，可能导致名称冲突。**C++标准提供了名称空间工具，以便更好的控制名称的作用域**.

### 传统的C++名称空间

1. **声明区域**是指**可以在其中进行声明的区域**。例如函数外面声明的全局变量,对于这种变量声明区域为其所在文件，对于函数中声明的变量，其声明区域为其所在代码块。
2. **潜在作用域**变量的潜在作用域为**从变量声明点开始到其声明区域结束**，因此潜在作用域比声明区域小，这是由于变量必须定义后才能使用。
3. 然而变量并非是在其潜在作用域一直可用的，他可能被另一个嵌套声明区域的同名变量覆盖，**变量对于程序而言可见的范围**称为**作用域**。

其区分的关键点，**声明区域用于表示这一个代码块存在这一个名称**，而**潜在作用域表示该变量物理上存在的区域**,**作用域表示变量可见的区域**

C++关于全局变量和局部变量的规则定义了一种名称空间层次，每个声明区域都可以声明名称，这些名称独立于其他名称中声明的名称，在一个函数中声明的局部变量不会与另外一个函数中声明的局部变量冲突。

### 新的名称空间特性

C++新增了一个功能，即通过**定义一种新的声明区域来创建命名的名称空间**，这样做的目的之一是提供一个声明名称的区域，**一个名称空间的名称不会与另一个命名空间的相同名称发生冲突** 来看一下实例

```cpp
namespace Jack // 名称空间 Jack
{
  double pail;
  void fetch();
  int pal;
  struct well;
}
namespace Jill // 名称空间 Jill
{
  double bucket(double n);
  double fetch;
  int pal;
  struct Hill;
}
```

**名称空间可以是全局的也可以位于另一个名称空间中，但不能位于代码块中**，因此在默认情况下名称空间声明的名称的链接性是外部的。

```cpp
namespace A { // 全局名称空间
    namespace A_sub { // 局部名称空间
        
    }
}
```

**除了用户定义的名称空间外，还有一个全局名称空间，他对应于文件级声明区域**，因此前面所说的**全局变量位于全局名称空间内**。任何名称空间内的名称不会与另外一个名称空间中的名称发生冲突.名称空间中的声明和定义规则和全局命名规则类似，**（类似于文件夹与子文件夹）**

**名称空间是开放的**，可以把已有的名称并入原有的名称空间，例如

```cpp
namespace A {
    int a;
    int b;
    int c;
    void fetch();
}
// ...
namespace A {
    int d;// 将d并入原来的A名称空间，也就是说可以分开写
}
// ...
namespace A {
    // 为前面的函数原型提供定义
    void fetch(){
        //...
    }
}
namespace A {
    namespace B {
        int a;
    }
}
```

如果**要访问名称空间中的名称最简单的办法是使用作用域解析符(::)**.

```cpp
A::a = 1;
A::b = 0;
A::B::a = 0; // 解析多层名称结构
```

**包含名称空间的名称称为限定的空间，不包含的成为未限定的名称。**

### using声明和using编译指令

我们并不希望每次使用名称都对其进行限定，C++提供了两种机制来简化对名称空间的名称的使用。**using声明使得特定的标识符可用，using编译指令使得整个名称空间可用。**

**using声明被限定的名称和他前面的关键词using组成**

```cpp
namespace A {
    int a;
}
using A::a;
```

**using声明将特定的名称添加到他所属的声明区域中**，如果在main函数中声明也可以使用a代替A::a.

由于using声明的作用域为其所在代码块所以也**存在局部变量覆盖全局变量**如下

```cpp
int a;
int main(){
	using A::a;
    cin >> a; // A::a
    cin >> ::a // 全局变量a
}
```

**using编译指令由名称空间名和他前面的关键字 using namespace**他使得该名称空间的所有名称可用不需要作用域解析符号，作用域也为其所在代码块。

```cpp
using namespace A; // 全局可用
//...
{
    using namespace A; // 代码块可用
    //...
}
```

**使用using声明和编译指令增加了名称冲突的可能性。**

#### using声明和using编译指令的比较

**使用using编译指令倒入一个名称空间中所用**名称与使用多个using声明是不一样的**。而更像是大量使用作用域解析运算符。**使用using声明就好像声明了相应的类型**，如果某个名称已经存在，则不能使用using声明。然而在使用using编译指令的情况将进行名称解析，就像包含了using声明和名称空间本省的最小声明区域中声明了名称一样。看实例

```cpp
namespace Jill
{
  double bucket(double n);
  double fetch;
  struct Hill{};
}
char fetch; // 全局变量
#include <iostream>
int main()
{   
    using namespace std;
    using namespace Jill;
    Hill Thrill; // == Jill:Thirill
    double water = bucket(2); // Jill:bucket(2)
    double fetch; // 隐藏了Jill::fetcj
    cin >> fetch; // == 局部 fecth
    cin >> ::fetch; // == 全局 fetch
    cin >> Jill::fetch; // Jill::fetch
}
```

**虽然编译指令将名称空间的名称是为在函数之外声明的（因为在函数内声明的变量可以覆盖它们）但是它并不能让该文件的其他函数能够使用这个名称。**

假设**名称空间和声明区域定义了相同的名称**，如果试图使用**using声明**将名称空间的名称导入该声明区域，**会导致发生出错**，如果使用
**using编译指令**将该名称空间的名称那么**局部名称会隐藏名称空间版本**。

一般来说**使用using声明指令会比使用using编译指令安全**,这是因为他只导入了特定的名称，如果改名与局部名称发生冲突，编译器将发出指示，using编译指令导入所有名称，可能包含并不需要名称，如果发生冲突，局部变量将会覆盖名称空间版本，编译器并不会发出警告，(这可能导致及其隐蔽的错误）

```cpp
// 不要这样做
using namespace std;
// 应该这样做
int x;
std::cin >> x;
std::cout << x << std::endl;
// 或者如下
using std::cin;
using std::cout;
using std::endl;
cin >> x;
cout << x << endl;
```

#### 其他特性

**名称空间可以嵌套**

```cpp
namespace A{
    namespace B{
        namespace C{
            int d;
        }
    }
}

// 解析 连续使用:: 解析
A::B::D::d = 1;

// using 也可以嵌套
using A::B:C::d;
d = 1; //== A::B::D::d = 1;
using namespace A::B::C;
d = 1;
```

**也可以在名称空间使用using声明和using编译指令**

```cpp
namespace A{
    int a;
}
namespace B{
    using namespace A;
    using A::a
}

// 解析a
A::a;
B::a;
```

**名称空间别名**

```cpp
namespace A{
    namespace B{
        namespace C{
            namespace D{
                //...
            }
        }
    }
}
using sub_D = A::B::C::D;
//就可以使用 sub_b 来替换 A::B::C::D;
```

**未命名名称空间**

这就像后面跟着using编译指令，该名称空间潜在作用区域为从声明点到声明区域末尾，在这个方面他与全局变量类似，但是由于缺少名称，因此不能显示的使用using编译指令或者using声明来使他在其余位置可用，具体的来说不能在未命名名称空间属于文件之外的文件中来使用该名称空间中的名称，这提供了链接性为内部的静态变量的替代品。

```cpp
static int counts;
int other();
int main(){
    //...
}

//等价于

namespace {
    int counts;
}
int other();
int main(){
    //...
}
```

### 名称空间实例

```cpp
//main.cpp
#include "namesp.h" // 导入头文件
#include <iostream>
void other();
void another();

int main(){
    using debets::Debt; // 使用作用域解析
    Debt golf{{"Llonvne","Lcosvle"},100};
    debets::showDebt(golf);
    other();
    another();
    return 0;
}

void other(){
    using std::cin;
    using std::cout;
    using std::endl;
    using namespace debets;
    Person dg{"Li","Hua"};
    showPerson(dg);
    cout << endl;
    Debt zippy[3];
    for (auto & i : zippy) {
        getDebt(i);
    }
    for (const auto& i : zippy){
        showDebt(i);
    }
    cout << "total debts" << sumDebt(zippy,3);
}

void another(){
    using pers::Person;
    Person collector = {"Millo","Right"};
    pers::showPerson(collector);
    std::cout << std::endl;
}

// namesp.h
#ifndef NAMESP_H
#define NAMESP_H

#include <string>
namespace pers
{
  using std::string;
  struct Person
  {
      string fname;
      string lname;
  };
  void getPerson(Person & person);
  void showPerson(const Person & person);
}

namespace debets
{
  using namespace pers;
  struct Debt
  {
      Person name;
      double amount{};
  };
  void getDebt(Debt & debt);
  void showDebt(const Debt & debt);
  double sumDebt(const Debt arr[], int n);
}

#endif //NAMESP_H

// namesp.cpp
#include <iostream>
#include "namesp.h"

namespace pers
{
    using std::cin;
    using std::cout;
    using std::endl;


    void getPerson(Person & person)
    {
        cout << "Enter you first name" << endl;
        cin >> person.fname;
        cout << "Enter you last name" << endl;
        cin >> person.fname;
    }

    void showPerson(const Person & person)
    {
        cout << person.fname << " " << person.lname;
    }
}

namespace debets
{
    void getDebt(Debt & debt)
    {
        getPerson(debt.name);
        std::cout << "Enter Debts: ";
        std::cin >> debt.amount;
    }

    void showDebt(const Debt & debt)
    {
        showPerson(debt.name);
        std::cout << ": $" << debt.amount << std::endl;
    }

    double sumDebt(const Debt * arr, int n)
    {
        double total = 0;
        for (int i = 0; i < n; ++i) {
            total += arr[i].amount;
        }
        return total;
    }
}
```

### 名称空间及其前途

1. 使用在已命名的名称空间中声明的变量而不是外部全局变量。

2. 使用在已命名的名称空间中声明的变量而不是静态全局变量。

3. 如果开发一个函数库或者类库，将其放在一个命名空间中，事实上C++现在提倡将标准函数放入std命名空间中，这种做法拓展到C语言库

4. 仅将使用编译指令using作为一种权宜之计。

5. 不要在头文件中使用using，这样做掩盖了让那些名称可用，另外，包含头文件的顺序可能影响程序，如果非要使用using编译指令将其放在所有#include文件后面。

6. 导入名称首选作用域解析符或者using声明

7. 对于using声明将其带作用域声明为局部而不是全局。

    别忘了使用名称空间的主旨是简化大型编程项目的管理工作对于只有一个文件的小程序使用using编译指令也不是什么大逆不道的事情。

    

