# 第九章_内存模型和命名空间

## 单独编译

C++允许甚至**鼓励程序员将组件函数放到独立的文件中**，在C++中可以单独编译这些文件，然后将它们链接成可执行的程序。（一般来说C++编译器及编译程序也管理链接器）

但是问题来了到底如何划分一个程序放到多个文件中，难道就是简单的讲他们分开吗？假如一个文件中包含了一份结构定义，那么如果在另一个文件也想使用这个定义，那就必须要包含结构声明，那随着使用的文件数量增多，就会出现相当声明，万一想要修改声明，难道要修改这么多份吗？所以**与其将其这么多声明单独的放到文件中，不如放在头文件中（.h）**,然后在每一份源码包含这一份头文件，这样修改声明的时候只需要在头文件做一次修改就可以了。

**所以可以将原来的程序分成三部分**

1. 头文件：包含结构声明和使用这些结构的函数的原型
2. 源代码文件：包含与结构相关的函数的代码
3. 源代码文件：包含调用与结构相关的函数的代码

**请不要将包含函数定义或者变量声明放到头文件中**，对于简单的可能可行，但是对于两份文件包含同一份头文件，会导致程序包含两个该程序的定义，除非函数是内联的否则将出错。

---

**头文件应该包含的内容:**

1. 函数原型
2. 使用 #define 或者 const 定义的符号常量
3. 结构声明
4. 类声明
5. 模版声明
6. 内联函数

将结构声明放在头文件是可行的，因为它们不变量，而是只是在源文件中创建结构时，告诉编译器如何创建该结构。

模版声明不是将被编译的代码，他只是告诉编译器如何生成与源代码中函数调用相匹配的函数定义。

被声明位const的数据和内联函数具有特殊的属性，被放在头文件不会引起问题

---

**在包含自己的头文件时候应该是用 "" 而不是 <>**

**在使用指令编译的时候只需要添加源代码文件而不需要头文件，这是因为 #include 会自动添加头文件**

**请不要使用 #include 来包含源代码文件，这样做会导致多重声明**

---

**头文件管理**

在同一个文件中只能将同一个头文件包含一次。但是很可能在不知情的情况包含了多次，例如可能使用另外一个头文件的头文件。有一种**C/C++标准技术可以避免多次包含同一头文件，他是基于预处理器编译指令#ifndef(if not define)**，下面的代码意味着只有没有定义过 POLAR_H 才执行 if 和 endif 中间的语句

```cpp
#ifndef POLAR_H // 如果没有定义 POLAR_H 执行
#define POLAR_H // 定义 POLAR_H 阻止第二次运行

// ... 

#endif //POLAR_H
```

编译器首次晕倒该头文件,名称 POLAR_H 没有定义 (我们通过文件名+下划线+ H + 下划线来统一命名防止重复).这种情况编译器将会编译中间的代码同时定义 POLAR_H ,如果在另外代码处再次包含头文件，编译器会发现 POLAR_H 已经被定义从而跳过编译。这种方法虽然不能防止头文件被包含两次，而知识让他忽略第一次包含以外所有的内容。大多数C/C++头文件都是用这种防护策略，不然定义多个结构两次可能导致错误。

**在IDE中往往会自动建立这种防护，而无需我们手工写入**

---

### 9.1 & 9.2 & 9.3 多文件编程实例

```cpp
// coordin.h
#ifndef COORDIN_H
#define COORDIN_H
// structures template
struct polar
{
    double distance;
    double angle;
};
struct rect
{
    double x;
    double y;
};
// prototypes
polar rect_to_polar(const rect&);
void show_polar(const polar&);
#endif //COORDIN_H
```

```cpp
// file1.cpp
#include <iostream>
#include "coordin.h"
using namespace std;

int main()
{
    rect rplace;
    polar pplace;

    cout << "Enter x and y value:" << endl;
    while (cin >> rplace.x >> rplace.y){
        pplace = rect_to_polar(rplace);
        show_polar(pplace);
        cout << "Next 2 number:" << endl;
    }
    return 0;
}
```

```cpp
// file2.cpp
#include <iostream>
#include <cmath>
#include "coordin.h"
using namespace std;

// convert rect to polar
polar rect_to_polar(const rect & xypos)
{
    polar answer;

    answer.distance = sqrt(pow(xypos.x, 2) + pow(xypos.y, 2));
    answer.angle = atan2(xypos.y, xypos.x);

    return answer;
}

void show_polar(const polar & dapos)
{
    const double Rad_to_deg = 57.29577951;

    cout << "distance = " << dapos.distance << endl;
    cout << "angle = " << dapos.angle * Rad_to_deg << " degrees" << endl;
}
```

```sh
# 使用 g++ 编译 不需要包含头文件
g++ -std=c++11 file1.cpp file2.cpp -o "xytpolar"
```

多两个源代码文件和新的头文件一起进行编译和链接，将生成一个可执行文件。

虽然我们讨论的是根据文件单独进行编译，但是为了保证通用性，C++标准使用了术语翻译单元，而不是文件。

---

## 存储持续性性，作用域，链接性

**C++使用三种（C++11使用四种）不同的方案来存储时间，四种方案的区别就是数据保留在内存中的时间**

1. 自动存储连续性：在函数定义中声明的变量（包括函数参数）的存储持续性性是自动的。它们在程序开始执行其所属的函数或者代码的时候被创建，在执行完函数或者代码块的时候被释放，C++有两种存储持续性位自动的变量。
2. 静态存储连续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态，它们在整个程序运行时都存在，C++有三种该类型的变量。
3. 线程存储持续型(C++11):不展开讨论
4. 动态存储持续性：用new运算符分配的内存将一直存在知道使用delete运算符将其释放，或者程序结束。这种内存持续性称为动态，有时被称为自由存储或者堆。

---

### 作用域和链接

**作用域**描述了名称在文件的多大范围是可见的

**链接性**描述了名称如何在不同文件（单元）内共享，链接性为外部的名称可以在文件间共享，链接性为内部的变量只能在同一个文件的函数共享。自动变量的名称没有链接性，所以他不能共享。

C++变量的作用域有多种

1. 作用域为局部的变量只在定义它的代码块可用，代码块是用{}括起多行代码
2. 作用域为全局（文件作用域）的变量在变量的定义位置到文件尾部都可以用。
3. 自动变量的作用域为局部
4. 静态变量的作用域取决他如何定义
5. 在函数原型作用域中使用的名称只在包含参数列表的括号中可以用。
6. 在类中声明的成员作用域为整个类。
7. 在名称空间中声明的变量作用域是整个命名空间（由于名称作用域已经引入C++语言，所以全局作用域是名称空间作用域的特例）

---

### 自动存储连续性

在默认情况下，**在函数定义中声明的变量（包括函数参数）的存储持续性性是自动的。作用域为局部，没有链接性，只有当程序执行到变量所在代码块时才为其分配内存，当函数结束时，这些变量都将消失。**（这边注意，执行到代码块的时候为其分配内存，但是作用域的起点是其声明位置）

如果在**代码块中定义变量那么其作用域和持续时间都限定在代码块**中，如果**一个变量名同时在内部代码块和外部代码块定义，我们说新的定义隐藏了旧的定义**，新定义可见，当程序离开该代码块时，原来的定义又重新可见。（该规则也适用于命名空间）

**在C++11中，auto用于类型推断，但是在C语言和C++之前的版本中他用于显示的指出变量为自动存储。用的人太少所以改了**

#### 自动变量的初始化：

可以使用任何在声明时其值为已知的表达式来初始化自动化变量

```cpp
int a = 1;
int b = 2 * a;
```

#### 自动变量与栈

由于自动变量的数目随着函数的开始和结束而增减，因此程序必须在运行时对自动变量进行管理，常用的方法是留出一段内存，将其视作栈，以管理变量的增减，子所以被称之为栈，是由于新数据被象征性的放在原有数据的上面，当程序使用完后，将其中栈中删除，栈的默认长度取决实现，但是编译器通常允许你定义长度。

#### 寄存器变量

关键字register是由C语言引入的,他建议CPU寄存器来存储自动变量，这旨在提高变量的访问速度。

在C++11之关键字用法没有变化，这种提示表示这个变量用的很多，编译器可对其进行特殊处理，在C++11中，这种提示作用也失去了，关键词register只是显式的指出变量时自动的，而关键词register本来就只能用自动变量，保留register的原因就是不想让使用了该关键字的代码非法。

### 静态持续变量

C++为静态存储持续性变量提供了3种链接性，分别是**外部链接性（可在其他文件中访问），内部链接性（只能在当前文件中访问），无链接性（只能在当前函数或者代码块中访问）**，这三种链接性都在**整个程序执行时期存在**，与自动变量相比它们的寿命更长，由于静态变量的数目在程序运行期间都是不变的，因此程序不需要使用特殊的装置来管理，**编译器将分配固定的内存块来存储所有的静态变量**；如果没有显示的初始化静态变量，编译器将其设置为0，**默认情况下静态数组和结构的每个元素或成员的所有位都设置为0**.

1. 想要创建链接性为外部的静态持续变量，必须要在代码块外部声明他。

2. 想要创建链接性为外部的静态持续变量，必须要在代码块外部声明他，并添加static修饰词
3. 要创建没有链接性的静态持续变量，必须在代码块内部声明他，并添加static修饰词

```cpp
int a = 1; // 链接性为外部的静态持续变量
static int b = 1; // 链接性为内部的静态持续变量
int main(){
	static int c = 1; // 无链接性的静态持续变量
	return 0;
}
```

上述所有的静态持续变量(a,b,c)在整个程序运行期间都存在。但是在main函数中声明的变量为无链接性的静态持续变量，也就说只能在main内部访问和修改该值。a没有被static修饰又处于外部术语外部链接性的静态持续变量，可在所有文件的访问，而变量b处于代码块外部但是被static修饰，属于内部连续性的静态持续变量，只能在该文件中使用。

**所有未初始化的静态持续变量的所有位都被设置为0，这种变量被称为0初始化的**。

---

**自动和静态持续性变量总结**

|     存储描述     | 持续性 | 作用域 | 链接性 | 如何声明                                  |
| :--------------: | :----: | ------ | ------ | ----------------------------------------- |
|       自动       |  自动  | 代码块 | 无     | 在代码块内部                              |
|      寄存器      |  自动  | 代码块 | 无     | 在代码块内部，且使用register修饰，C11失效 |
|  静态，无链接性  |  静态  | 代码块 | 无     | 在代码块内部，且使用static修饰            |
| 静态，外部链接性 |  静态  | 文件   | 外部   | 不在任何函数中                            |
| 静态，内部链接性 |  静态  | 文件   | 外部   | 不再任何函数中，且使用static修饰          |

我们会发现static在不同场景的意义并不相同，有人称之为关键字重载，即关键字意义取自于上下文。

---

**静态变量的初始化**

除了默认的零初始化外，还可以对静态变量进行**常量表达式初始化**和**动态初始化**

其中**常量表达式初始化和零初始化统称为静态初始化**，这意味者在编译器处理文件的时候初始化变量(编译时初始化)，动态初始化意味者将在编译后初始化。

那么编译器是如何执行初始化的呢，分为下面几步

1. 所有的静态变量都被分配内存和零初始化（无论是否被显示初始化）
2. 如果静态变量使用了常量表达式初始化了变量，且编译器仅根据文件内容（包括被包含的头文件）就可以计算表达式，编译器将执行常量表达式初始化，必要时编译器将进行简单运算，如果没有足量信息，变量将被动态初始化。

```cpp
#include <cmath>
int x; // 零初始化
int y = 5; // 静态初始化
long z = 13 * 13; // 静态初始化
const double pi = 4.0 * atan(1.0); // 动态初始化
```

pi因为设计到函数调用所以必须等到编译结束，程序链接后，程序运行时才能进行初始化。

### 静态持续性，外部链接性

**链接性为外部的变量通常简称为外部变量，它们存储持续性为静态，作用域为整个文件**，外部变量是在函数外部定义的，所以对于所有函数而言都是外部的。外部变量也可称为全局变量。

#### 1. 单定义规则

一方面，**在每个使用外部变量的文件，都必须声明他（一般由头文件#include完成）**,另一方面C++有**单定义规则**该规则指出变量只能有一次定义，为了满足这种需求，C++提供了两种变量声明，一个是定义声明简称为定义，该操作将为变量分配内存空间，另外一种是引用声明简称为声明，他不给变量分配空间，因为他引用已有的变量

**不难看出，单定义规则就指的是只能为同一个变量分配一次内存**

**引用变量使用关键词extern，且不进行初始化，否则声明为定义，导致分配存储空间**

---

实例1

```cpp
double up; // 定义 up初始化为0
extern int blem; // 声明 不分配内存 blem将在别处分配内存
extern char gr = 'z'; // 定义 被初始化需要分配内存空间 
```

实例2

```cpp
// file1.cpp
extern int cats = 20; // 定义 被初始化需要分配内存空间 == int cats = 20;
int dogs = 22; // 定义
int fleas; // 定义
// file2.cpp
extern int cats; // 声明从1处引用cats
extern int dogs; // 声明从1处引用dogs;
// file3
extern int cats; // 声明从1处引用cats
extern int dogs; // 声明从1处引用dogs;
extern int fleas;// 声明从1处引用fleas;
```

在2和3都用声明引用了cats和dogs变量，但是2没有声明fleas因此不可使用，其中1的第一句可以省略extern，效果相同

---

请注意**单定义规则并不意味着变量名不能相同**，例如在不同代码块声明的同名自动变量是彼此独立的，它们有自己的地址，另外局部变量可能隐藏同名的全局变量。程序中可包含多个同名的变量，但是每个变量都包含自己的定义。

**在同一个作用域中（不包含其内部的子作用域），只能有一个变量定义**

如果在函数中声明了与外部同名的变量，这种声明将会被视为一个自动变量的定义，当程序执行到自动变量所属的函数时，该变量将位于作用域中。

来看实例

```cpp
// main.cpp
#include <iostream>
using namespace std;

// 外部变量
double warming{0.3};

// 函数原型
void update(double dt);
void local();

int main(){
    cout << "Global warming is " << warming << endl;
    update(0.1);
    cout << "Global warming is " << warming << endl;
    local();
    cout << "Global warming is " << warming << endl;
    return 0;
}
// support.cpp
#include <iostream>
using namespace std;

// 变量声明
extern double warming;

// 函数原型
void update(double bt);
void local();

void update(double bt){
    extern double warming; // 这个声明时可选的，目的是指出使用的外部的warming
    warming += bt; // ::warming
    cout << "Update global warming to " << warming << endl; // ::warming
}

void local(){
    double warming = 0.8; // 
    cout << "local warming = " << warming << endl;
    cout << "but global warming is " << ::warming << endl;
}
```

**定义与全局变量相同的变量名后局部变量将隐藏全局变量**，例如函数定义局部变量warming后，当local函数使用warming时将使用局部版本。

C++比C语言更近一步，**它提供了作用域解析运算符号(::)，放在变量名前面，该运算符号表示使用变量的全局版本。**

从**清晰和避免的错误的角度来**说相对于使用 warming并依赖于作用域规则，在函数update中使用::warming是更好更安全的选择->**使用全局变量:使用 :: 表示**

---

**全局变量和局部变量**

既然可以使用全局变量和局部变量，选哪种呢？-> 首先全局变量很有吸引力，因为所有的函数都可以访问全局变量，不用传递参数，但是**易于访问的代价很大 --- 程序不可靠**，计算经验表明**程序越能避免对于数据的不必要的访问，就越能保证数据的完整性**。通常情况下应当使用局部变量，应当在需要知晓时传递数据，而不是不加区分的使用全局变量，后面我们可以看到**OOP在数据隔离方面又迈进一步**。

然而全局变量并不是一无是处，例如可以让多个函数使用同一块数据，外部数据尤其适于表示常量数据，因为这样可以增加const修饰符，以防数据被修改。

总的来说，**应当在合理的范围内缩小变量的作用域，为变量增加const修饰符**。

### 静态持续性，内部链接性

将static限定符用于作用域为整个文件的变量时，该变量的链接性将变为内部的，在多文件程序中内部链接性和外部链接性之间的差别很有意义，连接性为内部的变量只能在所属文件中使用，而连接性为外部的变量可以在所有文件中使用。

这边需要注意的是如果**在一个文件中定义了全局变量a，在另一个文件如果没有进行声明是不能使用，也不能再声明一个全局变量a.**

也就是说下述代码将不会通过编译

```cpp
// file1
int errors = 20;
// file2
int errors = 5;
void froobish(){
    cout << errors;
}
```

这个代码将会编译失败，他违反了单定义原则，记住**外部链接性的作用域是所有文件（即使可能某个文件没有声明导致无法访问，但是作用域仍然覆盖）**，所以即使在不同文件中声明两个同名的全局变量，仍然会导致在同一个作用域（除去子作用域）声明同名的变量导致冲突，违反单定义原则

简而言之**在多文件程序中，可以在一个文件中（也仅能在一个文件中）中定义一个外部变量，使用该变量的其他文件必须（也只能）通过extern声明他**

可使用外部变量在多文件程序中的不同部分共享数据，可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（命名空间提供另外一种方式来共享数据），另外如果将作用域为整个文件的变量修饰为静态的，就不必担心名称与其他文件中作用域为整个文件的变量发生冲突。

**我们可以这样理解，在不引入命名空间的前提下，所有文件之间是最大的作用域，声明的不带static修饰的不属于任何代码块的变量就属于该作用域，而带static修饰的不属于任何代码块的属于单个文件作用域，由于带static修饰的变量的作用域属于所有文件之间作用域的子集，相对于所有文件来说属于局部变量，所以不会发现名称冲突。**

### 静态存储持续性，无链接性

