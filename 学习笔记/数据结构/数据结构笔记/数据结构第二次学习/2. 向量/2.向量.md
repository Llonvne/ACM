# 2.向量

## **Abstract Data Type vs. Data struct**

**抽象数据类型** = **数据模型** + **定义在该模型上的一组操作**

抽象定义，且唯一，操作&语义化，不考虑时间复杂度，不涉及数据存储方式

**数据结构** = **基于某种特定的语言**，

具体实现，多种实现，内部的实现和表示，与复杂度密切相关，完整的算法，要考虑数据的具体存储机制



数据类型例如：int float char 都是数据类型，定义 + - * / 等操作

我们不知道他们如何实现以上操作，也并不需要知道。

**只需要知道他所说提供的操作，而无需关注其中的细节**，经过了抽象的数据类型，就称为**抽象数据类型**。

## **从数组到向量**

**C/C++中的数组**，且数组A[]中的元素与[0,n]的编号一一对应。且物理地址符合 $A[i] = A + s * i$其中s为每个元素所需要占用的空间

反之每个元素均由非负编号指代且可以直接访问，故称为线性数组。

**C/C++中的数组的一种拓展和泛化就是向量**由**一组元素按照线性次序封装而成**，**各个元素与[0,n]内的秩($rank$)一一对应**(call by rank 寻秩访问)，元素的类型不限于基本类型，操作，管理维护更加简化统一和安全，可以更加便捷的参加复杂数据结构的定制和实现

## 向量ADT接口

|      操作       |                        功能                        |   对象   |
| :-------------: | :------------------------------------------------: | :------: |
|    $size()$     |            报告向量当前的规模，元素总数            |   向量   |
|    $get(r)$     |                  获取秩为r的元素                   |   向量   |
|   $put(r,e)$    |               用e替换秩为r元素的数值               |   向量   |
|  $insert(r,e)$  |        e作为秩为r元素插入，其余元素像后移动        |   向量   |
|   $remove(r)$   |   删除秩序为r的元素，返回该元素中原来存放的对象    |   向量   |
| $disordered()$  |           判断所有元素是否按照非降序排序           |   向量   |
|    $sort()$     |       调整各个元素的位置，使之按照非降序排序       |   向量   |
|    $find(e)$    |                   查找目标元素e                    |   向量   |
|   $search(e)$   |      查找目标元素e，返回不大于e且秩最大的元素      | 有序向量 |
| $deduplicate()$ |                    剔除重复元素                    |   向量   |
|  $uniquify()$   |                    剔除重复元素                    | 有序向量 |
|  $traverse()$   | 遍历向量并统一处理所有元素，处理方法由函数对象指定 |   向量   |

**用户可以通过也只能通过这些接口对向量进行访问和修改**。

## Vector模版类 

```cpp
// Vector.h
#ifndef VECTOR_H
#define VECTOR_H

typedef int Rank; // 定义 秩
#define DEFAULT_CAPACITY (3)

template<typename T>
class Vector // 向量模版类
{
private:
    // 下划线一方面表示内部变量，一方面与下面的接口函数做出区分
    Rank _size; // 规模
    int _capacity; // 容量
    T * _elem; // 数据区域
protected:
public:
};


#endif //VECTOR_H
```

## 构造函数和析构函数

**构造函数**

```cpp
//--- 构造函数 ---//
    // 初始化容量构造函数
    explicit Vector(int c = DEFAULT_CAPACITY) // 使用 explicit 来禁止隐式转换 详见 C++单参数构造函数 隐式转换
    {
        _capacity = c; // 初始化容量
        _elem = new T[_capacity]; // 为数据区域开辟内存空间
        _size = 0; // 初始化规模
    }

    // 复制数组构造函数
    Vector(T const * A, Rank lo, Rank hi) // 通过 const 来确保不修改 A 数据和接受常量数组
    {
        copyFrom(A, lo, hi);
    }

    // 复制向量区间构造函数
    Vector(Vector<T> const & V, Rank lo, Rank hi)
    {
        copyFrom(V._elem, lo, hi); // 从向量区间复制，成员函数可以访问私有变量，所以直接访问 _elem
    }

    // 复制向量整体构造函数
    Vector(Vector<T> const & V)
    {
        copyFrom(V._elem, 0, V._size);
        // 函数区间复制，通过函数重载实现,等价于上面的 提供 0 和 size() 注意这边因为是成员函数可以使用_size,但是如果是用户只能使用 size()接口
    }

    //--- 构造函数 END ---//
```

**析构函数**

```cpp
    //--- 析构函数 ---//
    // 释放 new 开辟的 _elem 的空间
    ~Vector()
    {
        delete[] _elem;
    }
    //--- 析构函数 END ---//
```

**基于复制的构造**

以上的构造函数有一个问题就是如何实现copyFrom 函数

```cpp
template<typename T>
void Vector<T>::copyFrom(T * const A, Rank lo, Rank hi)
{
    _capacity = (hi - lo) * 2; // 开辟两倍于区间大小的内存，为什么后面讲
    _size = 0; // 规模清0
    
    // 复制元素
    while (lo < hi){
        _elem[_size] = A[lo]; // 复制
        
        // lo,size 递增
        ++_size;
        ++lo; 
    }
}
```



