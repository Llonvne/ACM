# 1. 绪论

# 算法

* 定义：基于特定的计算模型，旨在解决某一信息处理问题而设计的指令序列
* 应该具备的要素：输入和输出，基本操作，确定性和可行性，有穷性和正确性，退化和鲁棒性，重用性...

# 时间复杂度

## 渐进时间复杂度

**Big-O** 大O记号 ： 其实也就是 T(n) 的上界也就最坏时间复杂度

**大Ω记号** : 最好时间复杂度 下界

**大Θ记号**：准确时间复杂度 确界

## RAM 和 TM 模型

忽视环境差异，以基本操作的条数多少来衡量算法的好坏。

# 空间效率

对于几个时间复杂度记号对于空间复杂度也适用。

我们在实际生活中会更加多的关注时间复杂度。

# 复杂度分析

## 常数时间复杂度 O(1)

```c++
T(n) = O(1) // 常数复杂度
```

一般来说只含常数次数的基本操作的算法成为常数级别复杂度算法

## 常数空间复杂度 O(1)

一般来说我们在计算空间复杂度时会忽略输入占用的空间，也就是说如果一个算法只适用了常数级别的**辅助空间**，一般称为就地算法（原地算法）。

## 对数时间复杂度O(logn)

```c++
uint32_t countOnes(uint32_t n) {
    uint32_t ones = 0;
    while (0 < n){
        ones += (1 & n);
        n >>= 1;
    }
    return ones;
}
```

依据上面实例，我们不难发现，每次循环 n 都会少一半，也就说至多  floor(log~2~n) + 1 次就会结束

## 线性时间复杂度 O(n)

对于大多数问题而言，在遍历所有元素前根本不能得出答案，所以线性时间复杂度也是一个令人满意的答案 

## 多项式时间复杂度 O(f(n))

一般来说如果一个问题存在多项式范围内的算法，我们一般称为这个问题是易解的或者是可解的。

## 指数时间复杂度O(2^n^)

一般认为：指数级别时间复杂度的算法无法应用于实际问题中。他们不是有效算法，甚至不能成为算法。

# 递归

递归是函数和过程调用的一种特殊的形式，即允许函数自己调用自己。因其高度抽象性和间接性，已经成为主流的语言都支持的一种形式。

在设计递归的方法中最重要的即是平凡情况也称为**递归基**或者是退化，这种情况会返回一个非递归的结果来停止递归。其次则是如何将问题慢慢转化为平凡情况。

需要注意的是递归基本可能有多种。

## 线性递归

```c++
int sum(int A[],uint32_t n){
    if (1 > n){
        return 0;
    }
    return A[n - 1] + sum(A,n - 1);
}
```

我们会发现上述算法就是一个典型的线性递归。每次sum 都会从数组抽离最后一个元素然后与其他元素的元素相加，反复调用相加。

每次都把问题减少 O(1) 我们可以成为 **Decrease and Conquer** 减而治之

也就是递归每次深入的时候，每次将问题缩减一个常数(O(1)) ，直到退化成为平凡的情况。

## 递归分析

### 递归跟踪

一半这种方法适用于简单的递归程序，需要画出（数出）各层递归然后计算每层递归时间复杂度（忽略调用递归的语句），最后相加。

### 递归方程

如果递归跟踪是几何，那么递归方程就是代数。该方法无需分析具体的函数的调用而是基于每次递归深入时问题减少的规模来推断出。导出复杂度定界函数的**递推方程**和边界条件（**递推基**）,将复杂度求解转换为递归方程组求解。

## 递归模式

### 多递归集

```c++
// 通过函数重载实现递归版本和迭代版本
void reverse(int A[],int n){
	reverse(A,0,n);
}
// 递归函数
void reverse(int A[],int lo,int hi){ // O(n)
    if (lo >= hi){
        return;
    }
	swap(A[lo],A[hi - 1]);
    reverse(A,lo + 1,hi - 1);
}
```

其中这边有两个递归集 也就是 lo == hi 或者 lo >= hi

### 多向递归

也就是可以根据具体情况出现不同的递归方向。

## 递归消除 （递归 -> 迭代）

经上所述，我们发现递归可以让我们从宏观上理解和把握问题的实质，深入挖掘和洞悉算法过程的主要矛盾和一般性模式，最终设计出十分精简优美紧凑的算法，然而其存在的缺点也不容我们忽视。

### 成本

就操作系统而言每一次新建，删除，维护新的递归实例都会花费大量时间，就前面的简单的求和实例来说，迭代版本能够在更快的时间下轻松实现O(1)空间复杂度。

## 尾部递归及其消除

在线性递归算法中如果递归调用语句正好在最后一步出现，则称为尾部递归。



