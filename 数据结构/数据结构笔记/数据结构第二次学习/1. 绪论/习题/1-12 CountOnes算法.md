# 1-12 CountOnes 算法

现在要求写出一个算法能够算出一个整数 二进制展开后 1 的个数

## LogN 解

不难理解我们可以写出如下

```C++
// 统计参数 n 二进制展开后里面 1 的个数 O(logN)
int CountOnes(int n){
    int ones = 0;

    while (0 < n){
        ones += (1 & n) ; // 检查最低位
        n >>= 1; // 向右移动一位(去除最低位)
    }
    return ones;
}
```

我们会发现这一个logN的算法从某种意义上这是一个可行的算法，但是这还不够，我们是否能设计出一个算法，使其能使复杂度等于 n 中的1的个数 也就是 ones

## LogOnes 解

```c++
// 统计参数 n 二进制展开后里面 1 的个数 O(CountOnes(n)) 复杂度线性正比于 
// n 二进制展开后1的个数 == O(ones)
int CountOnes(int n){
    int ones = 0;
    while (0 < n){
        ++ones;
        n &= (n - 1); // 清楚最靠右的 1
    }
    return ones;
}
```

``` 
这个算法通过位运算的技巧将自右向左的逐个1翻转为0
不妨假设存在整数 n 二进制展开如下 x 表示未知
{ x, x, x, x, x, 1, 0, 0, 0, 0}
最低 k + 1 位必然是 1 0 0 0 0 , 即 1 后面跟上 k 个 0
相应的 n-1 展开如下
{ x, x, x, x, x, 0, 1, 1, 1, 1}
两者做与运算必为
{ x, x, x, x, x, 0, 0, 0, 0, 0}
也就是消除了最后一个 1
```

我们能够进一步利用二进制计算的技巧使得算法速度进一步提升呢？ 

## LogW解

```c++
// 统计参数 n 二进制展开后里面 1 的个数 O(log2W)
// 其中 W = O(log2N) 是整数的二进制表示的位宽
#define POW(c) (1 << (c)) // 2^c 宏实现
#define MASK(c) (((unsigned long) -1 ) / (POW(POW(c)) + 1))
// MASK(0) = 5555,5555(h) = 01010101,01010101,01010101,01010101(b)
// MASK(1) = 3333,3333(h) = 00110011,00110011,00110011,00110011(b)
// MASK(2) = 0f0f,0f0f(h)
// MASK(3) = 00ff,00ff(h)
// MASK(4) = 0000,ffff(h)

// 输入 n的二进制展开中，以 2^c 位为单位分组 各组数值已经分别等于原先这 2^c 位中1的数目
#define ROUND(n,c) (((n) & MASK(c)) + ((n) >> POW(c) & MASK(c)))
// 过程 以 2^c 位为单位分组，相邻的组两两捉对累加，累加值用原 2^(c+1) 就地记录
// 输出 n的二进制展开中，以 2^c 位为单位分组 各组数值已经分别等于 原先这个 2^(c+1)位中 1 的数目

int CountOnes(int n){
    n = ROUND( n, 0);
    n = ROUND( n, 1);
    n = ROUND( n, 2);
    n = ROUND( n, 3);
    n = ROUND( n, 4);
    return n;
}
// 三十二位字长 O(log_2(32)) = O(5) = O(1)
```





