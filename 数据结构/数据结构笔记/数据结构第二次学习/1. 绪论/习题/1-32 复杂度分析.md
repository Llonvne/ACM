# 1-32 复杂度分析

## 试分析以下函数 F(n) 并以大O记号形式确定其复杂度紧上界

### 01

```cpp
void F(int n){
    for (int i = 0;i < n;i++){
        for	(int j = 0;j < n;j++){
        }
    }
}
```

这个是最基本的二重循环的模式，其最大的特点循环控制变量按照算数级数变化，注意 {n,n,n,n,...,n} 也是算数级数，按照算数级数定理 时间复杂度位 O(n^2^)

采取算数级数的方式理解，不仅能够规避复杂的计算也能快速的得出结论

### 02

```cpp
void F(int n){
    for (int i = 0;i < n;i++){
        for	(int j = i;j < n;j++){
        }
    }
}
```

这里的循环变量为 {1,2,3,4,...,n} 也是算数级数，根据结论直接 O(n^2^)

### 03

```cpp
void F(int n){
    for (int i = 0;i < n;i++){
        for	(int j = 0;j < n;j+=2013){
        }
    }
}
```

这里的循环变量为 {1,1,2,2,...,n} 为每隔2013增长一次，但仍然属于算数级数范畴，直接 O(n^2^)

### 04

```cpp
void F(int n){
    for (int i = 0;i < n/2;i++){
        for	(int j = i;j < n;j+=1){
        }
    }
}
```

此题与第二题类似但是 i只取到 n/2 ,但是仍然属于算数级数 

{1,2,3,4,...,n/2} 最后一项平方后依然是 O(n^2^)

### 05

```cpp
void F(int n){
    for (int i = n/2;i < n;i++){
        for	(int j = 0;j < n - i;j+=1){
        }
    }
}
```

{n/2,n/2-1,n/2-2,....,1} 这里把循环倒过来 但是反过来看仍然是算数级数 最大项平方依然是 O(n^2^)

### 06

```cpp
void F(int n){
    for (int i = 1;i < n;i++){
        for	(int j = 1;j < n ;j <<= 1){ // j <<= 1 == j *= 2
        }
    }
}
```

内部循环是指数增长 O(logN)

外层循环 O(n)

总体时间复杂度 O(NlogN)

### 07

```cpp
void F(int n){
    for (int i = 1;i < n;i++){
        for	(int j = 1;j < 2013 ;j <<= 1){ // j <<= 1 == j *= 2
        }
    }
}
```

我们发现内部循环为常数次 所以复杂度仅有外部循环决定 O(n)

### 08

```cpp
void F(int n){
    for (int i = 1;i < n;i++){
        for	(int j = 1;j < 2013 ;j += i){
        }
    }
}
```

此时虽然内部变量j是算数级数但是步长却由 1->N

具体来说做 第 i 轮循环内 步长为 n/i

通过调和级数的性质不能算出 O(NlogN)

### 09

```cpp
void F(int n){
    for (int i = 0,j = 0;i < n;i+=j,j++);
}
```

这题 i 经过一轮循环递增 j

j 递增 1

不妨令 k 为循环轮数

i = k(k-1)/2

又因为 i < n ==> k(k-1)/2 < n

即 O(sqrt(n))

### 10:

```cpp
void F(int n){
    for (int i = 0,r = 1;i < n;i <<= r,r <<= 1);
}
```

经过每一轮循环

i *= 2^r^

r *= 2

经过k轮后

i= 2^( 2 ^ k - 1) < N

所以 k <= loglog N

O(LogLogN)

### 11:

```cpp
void F(int n){
    for (int i = 1;i < n;i = i= i << i);
}
```

每次迭代 i = 2^i^

我们知道指数的增长已经十分恐怖 但是 i = 2^i^ 则是更加恐怖的存在

这种级别的算法在人类可以感知的范围内都可以是作为常数

即使是宇宙内部基本粒子的总数 10^81 在这个算法也仅仅只需要 5 次就可以结束！！！

O(1)

### 12:

```cpp
int F(int n) {return (n > 0) ? G(G(n-1)) : 0};
int G(int n) {return (n > 0) ? G(n-1) + 2*n -1 ,0};
```

先分析G,我们发现G属于线性递归即每次递归问题规模减少 1 所以复杂度为 O(n)

在分析 F， 要注意 F 并非递归函数 ，他没有调用自己

内部的G（n-1） 是 O（n）,外部也是 O(n) 不难得出 F（n）是 O（n^2^）

